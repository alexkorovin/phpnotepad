unit Main;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, PHPEdit, ExtCtrls, ComCtrls, Menus, StdCtrls, Buttons, TabControl,
  ToolWin, ImgList, ClipBrd, CommDlg, WordBoxInit, CheckLst, Registry,
  StringListUnicodeSupport, XMLDoc, XMLIntf;

const
  MAX_HISTORY_REC = 100;

type
  THistoryRec = record
    Path: String;
    X: Integer;
    Y: Integer;
    ScrPos: Integer;
  end;

  TMainForm = class(TForm)
    StatusBar: TStatusBar;
    MainMenu: TMainMenu;
    ItOpen: TMenuItem;
    OpenDialog: TOpenDialog;
    Panel1: TPanel;
    Memo1: TMemo;
    PopupMenu: TPopupMenu;
    Splitter: TSplitter;
    ItNew: TMenuItem;
    Panel2: TPanel;
    ToolPanel: TPanel;
    SpeedButton2: TSpeedButton;
    SpeedButton3: TSpeedButton;
    SpeedButton4: TSpeedButton;
    SpeedButton5: TSpeedButton;
    SpeedButton7: TSpeedButton;
    pmSelectAll: TMenuItem;
    pmCut: TMenuItem;
    SpeedButton11: TSpeedButton;
    SpeedButton6: TSpeedButton;
    ImageList: TImageList;
    ToolBar: TToolBar;
    PrintBtn: TToolButton;
    ReplaceBtn: TToolButton;
    FindBtn: TToolButton;
    RedoBtn: TToolButton;
    UndoBtn: TToolButton;
    PasteBtn: TToolButton;
    CopyBtn: TToolButton;
    CutBtn: TToolButton;
    CloseAllBtn: TToolButton;
    CloseBtn: TToolButton;
    SaveAllBtn: TToolButton;
    SaveBtn: TToolButton;
    NewBtn: TToolButton;
    ExitBtn: TToolButton;
    OpenBtn: TToolButton;
    Sep_1: TToolButton;
    Sep_2: TToolButton;
    Sep_3: TToolButton;
    ItSave: TMenuItem;
    ItReopen: TMenuItem;
    ItSaveAs: TMenuItem;
    ItSaveAll: TMenuItem;
    ItClose: TMenuItem;
    ItCloseAll: TMenuItem;
    ItExit: TMenuItem;
    MEdit: TMenuItem;
    Search: TMenuItem;
    View: TMenuItem;
    Help: TMenuItem;
    PHPNotepad1: TMenuItem;
    About: TMenuItem;
    ItUndoItem: TMenuItem;
    ItRedoItem: TMenuItem;
    ItSep_1: TMenuItem;
    ItCut: TMenuItem;
    ItCopy: TMenuItem;
    ItPaste: TMenuItem;
    ItDelete: TMenuItem;
    ItSelectAll: TMenuItem;
    SpeedButton1: TSpeedButton;
    CloseQueryTimer: TTimer;
    ItFind: TMenuItem;
    ItReplace: TMenuItem;
    ItPrint: TMenuItem;
    MainPanel: TPanel;
    TabPanel: TPanel;
    Splitter1: TSplitter;
    MFile: TMenuItem;
    SaveDialog: TSaveDialog;
    Panel5: TPanel;
    ModeBar: TToolBar;
    HTMLBTN: TToolButton;
    PHPBTN: TToolButton;
    JSBTN: TToolButton;
    CSSBTN: TToolButton;
    TXTBTN: TToolButton;
    pmCopy: TMenuItem;
    pmPaste: TMenuItem;
    pmDelete: TMenuItem;
    XMLBTN: TToolButton;
    SpeedButton8: TSpeedButton;
    Label2: TLabel;
    Label1: TLabel;
    SpeedButton9: TSpeedButton;
    Encoding: TMenuItem;
    ItANSI: TMenuItem;
    ItUTF8: TMenuItem;
    ItUCSBigEndian: TMenuItem;
    ItUCS2LittleEndian: TMenuItem;
    N1: TMenuItem;
    IttoANSI: TMenuItem;
    IttoUTF8: TMenuItem;
    IttoUCS2BigEndian: TMenuItem;
    IttoUCS2LittleEndian: TMenuItem;
    PrintDialog: TPrintDialog;
    LicensePanel: TPanel;
    LicenseAgreeBox: TCheckBox;
    PageSeparator: TMenuItem;
    procedure ItOpenClick(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure ItNewClick(Sender: TObject);
    procedure pmCopyClick(Sender: TObject);
    procedure pmPasteClick(Sender: TObject);
    procedure pmDeleteClick(Sender: TObject);
    procedure SpeedButton2Click(Sender: TObject);
    procedure SpeedButton3Click(Sender: TObject);
    procedure SpeedButton4Click(Sender: TObject);
    procedure SpeedButton5Click(Sender: TObject);
    procedure SpeedButton6Click(Sender: TObject);
    procedure SpeedButton7Click(Sender: TObject);
    procedure pmSelectAllClick(Sender: TObject);
    procedure pmCutClick(Sender: TObject);
    procedure SpeedButton11Click(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure UndoBtnClick(Sender: TObject);
    procedure NewBtnClick(Sender: TObject);
    procedure RedoBtnClick(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure CloseQueryTimerTimer(Sender: TObject);
    procedure OpenBtnClick(Sender: TObject);
    procedure ItCopyClick(Sender: TObject);
    procedure ItDeleteClick(Sender: TObject);
    procedure ItPasteClick(Sender: TObject);
    procedure ItCutClick(Sender: TObject);
    procedure ItSelectAllClick(Sender: TObject);
    procedure ItUndoItemClick(Sender: TObject);
    procedure ItRedoItemClick(Sender: TObject);
    procedure ItSaveClick(Sender: TObject);
    procedure SaveBtnClick(Sender: TObject);
    procedure ItSaveAsClick(Sender: TObject);
    procedure ItCloseClick(Sender: TObject);
    procedure ItSaveAllClick(Sender: TObject);
    procedure ItCloseAllClick(Sender: TObject);
    procedure SaveAllBtnClick(Sender: TObject);
    procedure CloseBtnClick(Sender: TObject);
    procedure CloseAllBtnClick(Sender: TObject);
    procedure SaveDialogTypeChange(Sender: TObject);
    procedure HTMLBTNClick(Sender: TObject);
    procedure PHPBTNClick(Sender: TObject);
    procedure JSBTNClick(Sender: TObject);
    procedure CSSBTNClick(Sender: TObject);
    procedure TXTBTNClick(Sender: TObject);
    procedure ItExitClick(Sender: TObject);
    procedure CutBtnClick(Sender: TObject);
    procedure CopyBtnClick(Sender: TObject);
    procedure PasteBtnClick(Sender: TObject);
    procedure XMLBTNClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure SpeedButton8Click(Sender: TObject);
    procedure SpeedButton9Click(Sender: TObject);
    procedure ItFindClick(Sender: TObject);
    procedure ItReplaceClick(Sender: TObject);
    procedure FindBtnClick(Sender: TObject);
    procedure ReplaceBtnClick(Sender: TObject);
    procedure ExitBtnClick(Sender: TObject);
    procedure ItPrintClick(Sender: TObject);
    procedure LicenseAgreeBoxClick(Sender: TObject);
    procedure PrintBtnClick(Sender: TObject);
    procedure PHPNotepad1Click(Sender: TObject);
    procedure AboutClick(Sender: TObject);
    procedure PageSeparatorClick(Sender: TObject);
    procedure IttoANSIClick(Sender: TObject);
    procedure IttoUTF8Click(Sender: TObject);
    procedure IttoUCS2BigEndianClick(Sender: TObject);
    procedure IttoUCS2LittleEndianClick(Sender: TObject);
  private
    mdOpen: Boolean;
    procedure CMDialogKey(var msg: TCMDialogKey); message CM_DIALOGKEY;
    procedure AppMessage(var Msg: TMsg; var Handled: Boolean);
  public
    Docs: array of TPHPEdit;
    DocCloseTimer: array of TTimer;
    DocCounter: Integer;
    ActivDocID: Integer;
    TabControl: TTabControl;
    ReopenPath: String;
    ReadLicense: Integer;
    ShowSepLine: Boolean;
    HistoryList: array[0..MAX_HISTORY_REC - 1] of THistoryRec;
    BeginUserEdit: Boolean;
    procedure LoadDocFromFile(Path: String);
    procedure ChoiceTab(Sender: TObject; var TabID: Integer);
    procedure CloseTab(Sender: TObject; var TabID: Integer);
    procedure AssignActivDocWithMenu(ActivObj: TPHPEdit);
    procedure CloseTimerTab(Sender: TObject);
    procedure ChangeScanMode(SelectScanMode: TScanMode);
    procedure ReopenClick(Sender: TObject);
  end;

var
  MainForm: TMainForm;

implementation

uses Math, URForm, WordBox, Search, ShortHelp, ABox, Types;

{$R *.dfm}

procedure TMainForm.CMDialogKey(var msg: TCMDialogKey);
begin
  if msg.Charcode <> VK_TAB then inherited;
end;

procedure TMainForm.AppMessage(var Msg: TMsg; var Handled: Boolean);
var
  i: Integer;
begin
  if Msg.message = WM_KEYDOWN then begin
    BeginUserEdit := True;
    if Length(Docs) > 0 then begin
      if Docs[ActivDocID] <> nil then begin
        if (Docs[ActivDocID].CaretPos.Y <= Docs[ActivDocID].CurrentScanLineNo) and (ReadLicense = 1) then begin

          if (Msg.wParam = 46) and mdOpen then begin
            if not Docs[ActivDocID].TextSelected then begin
              Docs[ActivDocID].DeleteChar;
            end;
          end;

          if ((GetKeyState(VK_CONTROL) and 128) = 128) and (Msg.wParam = 32) then begin
            if Length(Docs) > 0 then begin
              if Docs[ActivDocID] <> nil then begin
                if WordBoxForm.Visible = False then begin
                  WordBoxForm.SetParams;
                  WordBoxForm.Visible := True;
                end;
              end;
            end;
            Handled := True;
          end;

          if ((GetKeyState(VK_SHIFT) and 128) = 128) and ((GetKeyState(VK_CONTROL) and 128) = 128) and (Msg.wParam = 85) then begin
            if Length(Docs) > 0 then begin
              if Docs[ActivDocID] <> nil then begin
                Docs[ActivDocID].ShiftBlockLeft;
              end;
            end;
            Handled := True
          end;

          if ((GetKeyState(VK_SHIFT) and 128) = 128) and ((GetKeyState(VK_CONTROL) and 128) = 128) and (Msg.wParam = 73) then begin
            if Length(Docs) > 0 then begin
              if Docs[ActivDocID] <> nil then begin
                Docs[ActivDocID].ShiftBlockRight;
              end;
            end;
            Handled := True
          end;

          if ((GetKeyState(VK_CONTROL) and 128) = 128) and (Msg.wParam = 38) then begin
            if Length(Docs) > 0 then begin
              if Docs[ActivDocID] <> nil then begin
                Docs[ActivDocID].ScrollLineUp;
              end;
            end;
            Handled := True
          end;

          if ((GetKeyState(VK_CONTROL) and 128) = 128) and (Msg.wParam = 40) then begin
            if Length(Docs) > 0 then begin
              if Docs[ActivDocID] <> nil then begin
                Docs[ActivDocID].ScrollLineDown;
              end;
            end;
            Handled := True
          end;

        end else Handled := True;
      end;
    end;
  end
  else if (Msg.message = WM_LBUTTONDOWN) or (Msg.message = WM_RBUTTONDOWN) then begin

  end
  else if Msg.message = WM_USER+1 then begin
    LoadDocFromFile(ReopenPath);
  end
  else if Msg.message = WM_USER+2 then begin
    LoadDocFromFile(ExtractFilePath(Application.ExeName)+'License.txt');
    for i := 0 to PopupMenu.Items.Count - 1 do begin
      PopupMenu.Items[i].Enabled := False;
    end;
    TXTBTN.Click;
  end;
end;

procedure TMainForm.LoadDocFromFile(Path: String);
var
  i: Integer;
  Ext: String;
begin
  BeginUserEdit := False;
  if not FileExists(Path) then begin
    raise Exception.CreateFmt('Cannot open file "'+Path+'" file not found.' , [name]);
    Exit;
  end;

  OpenDialog.FileName := '';

  SetLength(DocCloseTimer, Length(DocCloseTimer) + 1);
  DocCloseTimer[Length(DocCloseTimer)-1] := TTimer.Create(Self);
  DocCloseTimer[Length(DocCloseTimer)-1].Enabled := False;
  DocCloseTimer[Length(DocCloseTimer)-1].Interval := 10;
  DocCloseTimer[Length(DocCloseTimer)-1].OnTimer := CloseTimerTab;
  DocCloseTimer[Length(DocCloseTimer)-1].Tag := Length(DocCloseTimer)-1;

  SetLength(Docs, Length(Docs) + 1);
  Docs[Length(Docs)-1] := TPHPEdit.Create(MainPanel);
  Docs[Length(Docs)-1].SetDocState(dsOpen);
  Docs[Length(Docs)-1].SetDocPath(Path);

  Docs[Length(Docs)-1].AssignMainMenu(ItUndoItem, ItRedoItem, ItSave, ItSaveAll,
                                      ItCut, ItCopy, ItDelete,
                                      UndoBtn, RedoBtn, SaveBtn, SaveAllBtn,
                                      CutBtn, CopyBtn,
                                      pmCut, pmCopy, pmDelete,
                                      StatusBar, PrintDialog, ShowSepLine, Encoding);

  Docs[Length(Docs)-1].AssignScanList(PHPReservList, PHPFuncList, HtmlTagList,
                                      HtmlAttrList, HtmlMethodsList, JSObjectList, JSMethodsList,
                                      JSPropList, JSReservList, CSSAttrList,
                                      CSSValList);

  Docs[Length(Docs)-1].SetScanStartLine(0);
  TabControl.AddTab(ExtractFileName(Path), Length(Docs)-1);
  Docs[Length(Docs)-1].ID := Length(Docs)-1;
  MainPanel.Repaint;

  MainPanel.Perform(WM_SETREDRAW,0,0);
  for i := 0 to Length(Docs) - 1 do begin
    if Docs[i] <> nil then
      Docs[i].Visible := False;
  end;
  MainPanel.Perform(WM_SETREDRAW,1,0);
  Docs[Length(Docs)-1].Visible := True;
  Docs[Length(Docs)-1].SetCursor(1,0);

  ChangeScanMode(smYes);

  ItSaveAs.Enabled := True;
  ItClose.Enabled := True;
  ItCloseAll.Enabled := True;
  ItPrint.Enabled := True;
  ItSelectAll.Enabled := True;
  CloseBtn.Enabled := True;
  CloseAllBtn.Enabled := True;
  PrintBtn.Enabled := True;
  ItFind.Enabled := True;
  ItReplace.Enabled := True;
  FindBtn.Enabled := True;
  ReplaceBtn.Enabled := True;
  pmPaste.Enabled := True;
  pmSelectAll.Enabled := True;
  mdOpen := True;

  Ext := ExtractFileExt(Path);

  ChangeScanMode(smTXT);

  case OpenDialog.FilterIndex of
    4:ChangeScanMode(smHTML);
    1:ChangeScanMode(smPHP);
    2:ChangeScanMode(smJS);
    3:ChangeScanMode(smJS);
    5:ChangeScanMode(smCSS);
    6:ChangeScanMode(smXML);
    7:ChangeScanMode(smTXT);
  end;

  Docs[Length(Docs)-1].LoadFromFile(Path);
  TabControl.Update;

  for i := 0 to MAX_HISTORY_REC - 1 do begin
    if HistoryList[i].Path = Path then begin
      if not BeginUserEdit then begin
        Docs[Length(Docs)-1].ScrollTo(HistoryList[i].ScrPos);
        Docs[Length(Docs)-1].SetCursor(HistoryList[i].X, HistoryList[i].Y);
      end;
      Break;
    end;
  end;
end;

procedure TMainForm.FormCreate(Sender: TObject);
var
  Reg: TRegistry;
  i,j: Integer;
  XMLDocument: TXMLDocument;
  Root, Child: IXMLNode;
  AFile: String;
  TopIndex: Integer;
begin
  Application.OnMessage := AppMessage;
  TabControl := TTabControl.Create(TabPanel);
  TabControl.Align := alTop;
  TabControl.OnChoiceTab := ChoiceTab;
  TabControl.OnCloseTab := CloseTab;
  DocCounter := 0;

  DoubleBuffered := True;
  MainPanel.DoubleBuffered := True;

  if ParamCount > 0 then begin
    LoadDocFromFile(ParamStr(1));
  end;

  InitScaner;

  //ReadLicense := -1;
  ReadLicense := 1;
  ShowSepLine := True;
  Reg := TRegistry.Create;
  try
    try
      Reg.RootKey :=  HKEY_CURRENT_USER;
      Reg.OpenKey('Software\PHPNotepad',true);
      Left := Reg.ReadInteger('Left');
      Top := Reg.ReadInteger('Top');
      Width := Reg.ReadInteger('Width');
      Height := Reg.ReadInteger('Height');
      ReadLicense := Reg.ReadInteger('ReadLicense');
      ShowSepLine := Reg.ReadBool('SepLine');

      if ShowSepLine then PageSeparator.Checked := True
        else PageSeparator.Checked := False;

      if Reg.ReadInteger('Maximized') <> 0 then WindowState := wsMaximized
        else WindowState := wsNormal;

    except
    end;
  finally
    Reg.free;
  end;

  try
    AFile := ExtractFilePath(Application.ExeName)+'\AppData\history.xml';
    XMLDocument := TXMLDocument.Create(Application);
    XMLDocument.LoadFromFile(AFile);
    XMLDocument.Active := True;

    Root := XMLDocument.DocumentElement;
    TopIndex := 0;
    for i := 0 to Root.ChildNodes.Count - 1 do begin
      if Root.ChildNodes[i].NodeName = 'File' then begin
        Child := Root.ChildNodes[i];
        for j := 0 to Child.ChildNodes.Count - 1 do begin
          if Child.ChildNodes[j].NodeName = 'Path' then begin
            HistoryList[TopIndex].Path := Child.ChildNodes[j].Text;
          end;
          if Child.ChildNodes[j].NodeName = 'X' then begin
            HistoryList[TopIndex].X := StrToInt(Child.ChildNodes[j].Text);
          end;
          if Child.ChildNodes[j].NodeName = 'Y' then begin
            HistoryList[TopIndex].Y := StrToInt(Child.ChildNodes[j].Text);
          end;
          if Child.ChildNodes[j].NodeName = 'Pos' then begin
            HistoryList[TopIndex].ScrPos := StrToInt(Child.ChildNodes[j].Text);
          end;
        end;
        if TopIndex < MAX_HISTORY_REC - 2 then Inc(TopIndex);
      end;
    end;

  except
    Exit;
  end;

  if ReadLicense <> 1 then begin
    for i := 0 to MainMenu.Items.Count - 1 do begin
      MainMenu.Items[i].Enabled := False;
    end;

    ToolPanel.Enabled := False;
    ModeBar.Enabled := False;
    TabPanel.Enabled := False;
    LicensePanel.Visible := True;
    PostMessage(Handle, WM_USER+2, 0, 0);
  end else begin
    for i := 0 to MainMenu.Items.Count - 1 do begin
      MainMenu.Items[i].Enabled := True;
    end;

    ToolPanel.Enabled := True;
    ModeBar.Enabled := True;
    TabPanel.Enabled := True;
    LicensePanel.Visible := False;
  end;
end;

procedure TMainForm.FormActivate(Sender: TObject);
begin
  WordBoxForm.Visible := False;
end;

procedure TMainForm.ItOpenClick(Sender: TObject);
var
  i: Integer;
  flag: Boolean;
begin
  flag := False;
  if OpenDialog.Execute then begin
    for i := 0 to Length(Docs) - 1 do begin
      if Docs[i] <> nil then begin
        if Docs[i].GetDocPath = OpenDialog.FileName then begin
          flag := True;
          TabControl.SelectTab(Docs[i].ID);
        end;
      end;
    end;
    if not flag then LoadDocFromFile(OpenDialog.FileName);
  end;
  TabControl.Refresh;
end;

procedure TMainForm.ItNewClick(Sender: TObject);
var
  i,j, NewInd: Integer;
  NewName, No, S: String;
  dgflag: Boolean;
  ExistNoArray: array of Integer;
begin
  SetLength(DocCloseTimer, Length(DocCloseTimer) + 1);
  DocCloseTimer[Length(DocCloseTimer)-1] := TTimer.Create(Self);
  DocCloseTimer[Length(DocCloseTimer)-1].Enabled := False;
  DocCloseTimer[Length(DocCloseTimer)-1].Interval := 10;
  DocCloseTimer[Length(DocCloseTimer)-1].OnTimer := CloseTimerTab;
  DocCloseTimer[Length(DocCloseTimer)-1].Tag := Length(DocCloseTimer)-1;

  MainPanel.Perform(WM_SETREDRAW,0,0);
  SetLength(Docs, Length(Docs) + 1);
  Docs[Length(Docs)-1] := TPHPEdit.Create(MainPanel);
  Docs[Length(Docs)-1].AssignMainMenu(ItUndoItem, ItRedoItem, ItSave, ItSaveAll,
                                      ItCut, ItCopy, ItDelete,
                                      UndoBtn, RedoBtn, SaveBtn, SaveAllBtn,
                                      CutBtn, CopyBtn,
                                      pmCut, pmCopy, pmDelete,
                                      StatusBar, PrintDialog, ShowSepLine, Encoding);

  Docs[Length(Docs)-1].AssignScanList(PHPReservList, PHPFuncList, HtmlTagList,
                                      HtmlAttrList, HtmlMethodsList, JSObjectList, JSMethodsList,
                                      JSPropList, JSReservList, CSSAttrList,
                                      CSSValList);

  Docs[Length(Docs)-1].SetScanStartLine(0);
  Docs[Length(Docs)-1].GoScan;

  //New Tab Index
  SetLength(ExistNoArray, 0);
  for i := 0 to TabControl.GetTabCount - 1 do begin
    S := TabControl.Title(i);
    if (Copy(S,1,9) = 'untitled ') then begin
      No := Copy(S,10,Length(S));
      dgflag := False;
      if (Length(No) > 0) then begin
        dgflag := True;
        if not(No[1] in ['1'..'9']) then begin
          dgflag := False;
        end else begin
          for j := 2 to Length(No) do begin
            if not(No[j] in ['0'..'9']) then begin
              dgflag := False;
            end;
          end;
        end;
        if dgflag then begin
          SetLength(ExistNoArray, Length(ExistNoArray) + 1);
          try
            ExistNoArray[Length(ExistNoArray)-1] := StrToInt(No);
          except
            ExistNoArray[Length(ExistNoArray)-1] := -1;
          end;
        end;
      end;
    end;
  end;

  NewInd := 1;
  while True do begin
    dgflag := True;
    for i := 0 to Length(ExistNoArray) - 1 do begin
      if NewInd = ExistNoArray[i] then begin
        dgflag := False;
        Inc(NewInd);
      end;
    end;  
    if dgflag then Break;
  end;

  Docs[Length(Docs)-1].SetDocPath('untitled '+ IntToStr(NewInd));
  Docs[Length(Docs)-1].SetDocState(dsNew);
  TabControl.AddTab('untitled '+ IntToStr(NewInd), Length(Docs)-1);
  Docs[Length(Docs)-1].ID := Length(Docs)-1;
  //End New Tab Index

  for i := 0 to Length(Docs) - 1 do begin
    if Docs[i] <> nil then
      Docs[i].Visible := False;
  end;
  MainPanel.Perform(WM_SETREDRAW,1,0);

  Docs[Length(Docs)-1].Visible := True;
  Docs[Length(Docs)-1].Repaint;

  TabControl.Update;
  Repaint;

  ItSaveAs.Enabled := True;
  ItClose.Enabled := True;
  ItCloseAll.Enabled := True;
  ItPrint.Enabled := True;
  ItSelectAll.Enabled := True;
  CloseBtn.Enabled := True;
  CloseAllBtn.Enabled := True;
  PrintBtn.Enabled := True;
  ItFind.Enabled := True;
  ItReplace.Enabled := True;
  FindBtn.Enabled := True;
  ReplaceBtn.Enabled := True;
  pmPaste.Enabled := True;
  pmSelectAll.Enabled := True;
  mdOpen := True;

  ChangeScanMode(smYes);
  ChangeScanMode(smPHP);  
end;

procedure TMainForm.ChoiceTab(Sender: TObject; var TabID: Integer);
var
  i: Integer;
begin
  Caption := 'PHPNotepad - ' + Docs[TabID].GetDocPath;

  OnMouseWheelDown := Docs[TabID].WheelDown;
  OnMouseWheelUp := Docs[TabID].WheelUp;
  OnKeyPress := Docs[TabID].KeyPress;
  OnKeyDown := Docs[TabID].KeyDown;
  OnKeyUp := Docs[TabID].KeyUp;

  MainPanel.Perform(WM_SETREDRAW,0,0);
  for i := 0 to Length(Docs) - 1 do begin
    if Docs[i] <> nil then
      Docs[i].Visible := False;
  end;
  MainPanel.Perform(WM_SETREDRAW,1,0);
  Docs[TabID].Visible := True;
  Docs[TabID].Repaint;

  AssignActivDocWithMenu(Docs[TabID]);
  ActivDocID := TabID;
  
  SearchForm.PHPEditor := Docs[ActivDocID];
end;

procedure TMainForm.CloseTimerTab(Sender: TObject);
begin
  if not Docs[TTimer(Sender).Tag].InScan then begin
    FreeAndNil(Docs[TTimer(Sender).Tag]);
    FreeAndNil(DocCloseTimer[TTimer(Sender).Tag]);
  end;

  if TabControl.GetTabCount = 0 then
    ChangeScanMode(smNo);
end;

procedure TMainForm.CloseTab(Sender: TObject; var TabID: Integer);
var
  i, BtnSelID: Integer;
  flag, ffglag: Boolean;
  NewFileName, Path: String;
  CloseItem: TMenuItem;
begin
  if Docs[TabID].Modified then begin
    ShortHelpForm.Close;
    SearchForm.Close;
    AboutBox.Close;

    BtnSelID := MessageBox(Handle, PChar('Save file "'+Docs[TabID].GetDocPath+'" ?'), PChar('Save'), MB_YESNOCANCEL+MB_ICONQUESTION);

    if BtnSelID = mrCancel then begin
      TabId := -1;
      Exit;
    end;

    if BtnSelID = mrYes then begin
      if Docs[TabID].GetDocState = dsOpen then begin
        Docs[TabID].SaveToFile(Docs[TabID].GetDocPath);
      end;
      if Docs[TabID].GetDocState = dsNew then begin
        SaveDialog.FilterIndex := Docs[ActivDocID].FilterIndex;
        NewFileName := Docs[ActivDocID].GetDocPath;
        Path := ExtractFilePath(NewFileName);

        case SaveDialog.FilterIndex of
          1: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.php';
          2: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.js';
          3: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.json';
          4: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.html';
          5: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.css';
          6: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.xml';
          7: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.txt';
          8: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '';
        end;
        SaveDialog.FileName := Path + NewFileName;

        if SaveDialog.Execute then begin
          ItSave.Enabled := False;
          SaveBtn.Enabled := False;
          Docs[ActivDocID].SaveToFile(Path + NewFileName);
          Docs[ActivDocID].SetDocPath(Path + NewFileName);
          Docs[ActivDocID].SetDocState(dsOpen);
          Docs[ActivDocID].CommitModify;
          TabControl.RenameTab(ActivDocID, ExtractFileName(NewFileName));
          TabControl.Update;
          Caption := 'PHPNotepad - ' + SaveDialog.FileName;
        end;
      end;
    end;
  end;

  if TabControl.GetTabCount = 1 then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled := False;
    ItRedoItem.Enabled := False;
    RedoBtn.Enabled := False;
    ItSave.Enabled := False;
    SaveBtn.Enabled := False;
    ItSaveAll.Enabled := False;
    SaveAllBtn.Enabled := False;
    ItSaveAs.Enabled := False;
    ItClose.Enabled := False;
    ItCloseAll.Enabled := False;
    ItPrint.Enabled := False;
    CloseBtn.Enabled := False;
    CloseAllBtn.Enabled := False;
    PrintBtn.Enabled := False;
    ItCut.Enabled := False;
    ItCopy.Enabled := False;
    CutBtn.Enabled := False;
    CopyBtn.Enabled := False;
    ItPaste.Enabled := False;
    PasteBtn.Enabled := False;
    ItDelete.Enabled := False;
    ItFind.Enabled := False;
    ItReplace.Enabled := False;
    FindBtn.Enabled := False;
    ReplaceBtn.Enabled := False;
    ItSelectAll.Enabled := False;
    pmPaste.Enabled := False;
    pmSelectAll.Enabled := False;
    pmCut.Enabled := False;
    pmCopy.Enabled := False;
    pmDelete.Enabled := False;
    mdOpen := False;

    OnMouseWheelDown := nil;
    OnMouseWheelUp := nil;
    OnKeyPress := nil;
    OnKeyDown := nil;
    OnKeyUp := nil;
    Caption := 'PHPNotepad';

    StatusBar.Panels[0].Text := '';
    StatusBar.Panels[1].Text := '';
    StatusBar.Panels[2].Text := '';

    SearchForm.Visible := False;
  end;

  flag := False;
  for i := 0 to Length(Docs) - 1 do begin
    if (Docs[i] <> nil) and (Docs[i].Modified) and (i <> TabID) then flag := True;
  end;

  if not flag then begin
    ItSaveAll.Enabled := False;
    SaveAllBtn.Enabled := False;
  end;

  if Docs[ActivDocID].GetDocState = dsOpen then begin
    flag := False;
    for i := 0 to ItReopen.Count - 1 do begin
      if ItReopen.Items[i].Hint = Docs[TabID].GetDocPath then begin
        flag := True;
        Break;
      end;
    end;

    if not flag then begin
      CloseItem := TMenuItem.Create(Self);
      CloseItem.Caption := Docs[TabID].GetDocPath;
      CloseItem.Hint := Docs[TabID].GetDocPath;
      CloseItem.OnClick := ReopenClick;
      ItReopen.Insert(0,CloseItem);

      for i := 0 to ItReopen.Count - 1 do begin
        ItReopen.Items[i].Tag := i;
      end;

      if ItReopen.Count > 10 then begin
        ItReopen.Delete(10);
      end;
    end;
  end;
  ffglag := False;
  for i := 0 to MAX_HISTORY_REC - 1 do begin
    if HistoryList[i].Path = Docs[TabID].GetDocPath then begin
      HistoryList[i].X := Docs[TabID].CaretPos.X;
      HistoryList[i].Y := Docs[TabID].CaretPos.Y;
      HistoryList[i].ScrPos := Docs[TabID].GetVertScrollPos;
      ffglag := True;
      Break;
    end;
  end;

  if not ffglag then begin
    for i := MAX_HISTORY_REC - 1 downto 1 do begin
      HistoryList[i].Path := HistoryList[i-1].Path;
      HistoryList[i].X := HistoryList[i-1].X;
      HistoryList[i].Y := HistoryList[i-1].Y;
      HistoryList[i].ScrPos := HistoryList[i-1].ScrPos;
    end;
    HistoryList[0].Path := Docs[TabID].GetDocPath;
    HistoryList[0].X := Docs[TabID].CaretPos.X;
    HistoryList[0].Y := Docs[TabID].CaretPos.Y;
    HistoryList[0].ScrPos := Docs[TabID].GetVertScrollPos;
  end;

  Docs[TabID].Terminate;
  DocCloseTimer[TabID].Enabled := True;
end;

procedure TMainForm.ReopenClick(Sender: Tobject);
var
  i: Integer;
begin
  ItReopen.Delete(TMenuItem(Sender).Tag);

  for i := 0 to ItReopen.Count - 1 do begin
    ItReopen.Items[i].Tag := i;
  end;

  ReopenPath := TMenuItem(Sender).Hint;
  PostMessage(Handle, WM_USER+1, 0, 0);
end;

procedure TMainForm.AssignActivDocWithMenu(ActivObj: TPHPEdit);
var
  EncStr: String;
begin
  if ActivObj.GetUndoCount = 0 then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled := False;
  end else begin
    ItUndoItem.Enabled := True;
    UndoBtn.Enabled := True;
  end;

  if ActivObj.GetRedoCount = 0 then begin
    ItRedoItem.Enabled := False;
    RedoBtn.Enabled := False;
  end else begin
    ItRedoItem.Enabled := True;
    RedoBtn.Enabled := True;
  end;

  if ActivObj.Modified then begin
    ItSave.Enabled := True;
    ItSaveAll.Enabled := True;
    SaveBtn.Enabled := True;
    SaveAllBtn.Enabled := True;
  end else begin
    ItSave.Enabled := False;
    SaveBtn.Enabled := False;
  end;

  if ActivObj.TextSelected then begin
    ItCut.Enabled := True;
    ItCopy.Enabled := True;
    CutBtn.Enabled := True;
    CopyBtn.Enabled := True;
    ItDelete.Enabled := True;
  end else begin
    ItCut.Enabled := False;
    ItCopy.Enabled := False;
    CutBtn.Enabled := False;
    CopyBtn.Enabled := False;
    ItDelete.Enabled := False;
  end;

  ItPaste.Enabled := True;
  PasteBtn.Enabled := True;

  case ActivObj.ScanMode of
    smPHP: PHPBTN.Down := True;
    smHTML: HTMLBTN.Down := True;
    smJS: JSBTN.Down := True;
    smCSS: CSSBTN.Down := True;
    smXML: XMLBTN.Down := True;
    smTXT: TXTBTN.Down := True;
  end;

  StatusBar.Panels[0].Text := ' Ln:' + IntToStr(ActivObj.CaretPos.Y + 1);
  StatusBar.Panels[1].Text := ' Col:' + IntToStr(ActivObj.CaretPos.X);
  EncStr := ActivObj.FStringList.EncodingStr;
  StatusBar.Panels[2].Text := EncStr;

  if EncStr = 'ANSI' then ItANSI.Checked := True;
  if EncStr = 'UTF-8 BOM' then ItUTF8.Checked := True;
  if EncStr = 'UCS-2 LE' then ItUCS2LittleEndian.Checked := True;
  if EncStr = 'UCS-2 BE' then ItUCSBigEndian.Checked := True;
end;

procedure TMainForm.pmCopyClick(Sender: TObject);
begin
  ItCopy.Click;
end;

procedure TMainForm.pmPasteClick(Sender: TObject);
begin
  ItPaste.Click;
end;

procedure TMainForm.pmDeleteClick(Sender: TObject);
begin
  ItDelete.Click;
end;

procedure TMainForm.pmSelectAllClick(Sender: TObject);
begin
  ItSelectAll.Click;
end;

procedure TMainForm.pmCutClick(Sender: TObject);
begin
  ItCut.Click;
end;

procedure TMainForm.UndoBtnClick(Sender: TObject);
begin
  ItUndoItem.Click;
end;

procedure TMainForm.NewBtnClick(Sender: TObject);
begin
  ItNew.Click;
end;

procedure TMainForm.SaveBtnClick(Sender: TObject);
begin
  ItSave.Click;
end;

procedure TMainForm.RedoBtnClick(Sender: TObject);
begin
  ItRedoItem.Click;
end;

procedure TMainForm.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
var
  i: Integer;
  Reg: TRegistry;
  HistList: TStringList;
begin
  SearchForm.Visible := False;

  CanClose := False;
  ItCloseAll.Click;

  Reg := TRegistry.Create;
  try
    try
      Reg.RootKey :=  HKEY_CURRENT_USER;
      Reg.OpenKey('Software\PHPNotepad',true);
      Reg.WriteInteger('Left', Left);
      Reg.WriteInteger('Top', Top);
      Reg.WriteInteger('Width', Width);
      Reg.WriteInteger('Height', Height);
      Reg.WriteBool('SepLine', ShowSepLine);
      if WindowState = wsMaximized then Reg.WriteInteger('Maximized', 1);
      if WindowState = wsNormal then Reg.WriteInteger('Maximized', 0);
    except
    end;
  finally
    Reg.free;
  end;

  try
    HistList := TStringList.Create;
    HistList.Add('<?xml version="1.0" encoding="UTF-8" ?>');
    HistList.Add('<PHPNotepad>');
    for i := 0 to MAX_HISTORY_REC - 1 do begin
      HistList.Add('  <File>');
      HistList.Add('    <Path>'+HistoryList[i].Path+'</Path>');
      HistList.Add('    <X>'+IntToStr(HistoryList[i].X)+'</X>');
      HistList.Add('    <Y>'+IntToStr(HistoryList[i].Y)+'</Y>');
      HistList.Add('    <Pos>'+IntToStr(HistoryList[i].ScrPos)+'</Pos>');
      HistList.Add('  </File>');
    end;
    HistList.Add('</PHPNotepad>');
    HistList.SaveToFile(ExtractFilePath(Application.ExeName)+'\AppData\history.xml');
  except
  end;

  if TabControl.GetTabCount = 0 then begin
    for i := 0 to Length(Docs) - 1 do begin
      if Docs[i] <> nil then begin
        Docs[i].Terminate;
        DocCloseTimer[i].Enabled := True;
      end;
    end;

    CloseQueryTimer.Enabled := True;
  end;
end;

procedure TMainForm.CloseQueryTimerTimer(Sender: TObject);
var
  i: Integer;
  flag: Boolean;
begin
  flag := False;
  for i := 0 to Length(Docs) - 1 do begin
    if Docs[i] <> nil then flag := true;
  end;      

  if not flag then begin
    Application.Terminate;
  end;
end;


procedure TMainForm.OpenBtnClick(Sender: TObject);
begin
  ItOpen.Click;
end;

procedure TMainForm.ItCopyClick(Sender: TObject);
begin
  Docs[ActivDocID].CopyToClipBoard;
end;

procedure TMainForm.ItDeleteClick(Sender: TObject);
begin
  Docs[ActivDocID].DeleteTx;
end;

procedure TMainForm.ItPasteClick(Sender: TObject);
begin
  Docs[ActivDocID].Paste;
end;

procedure TMainForm.ItCutClick(Sender: TObject);
begin
  Docs[ActivDocID].Cut;
end;

procedure TMainForm.ItSelectAllClick(Sender: TObject);
begin
  Docs[ActivDocID].SelectAll;
end;

procedure TMainForm.ItUndoItemClick(Sender: TObject);
begin
  if not(Docs[ActivDocID].CaretPos.Y <= Docs[ActivDocID].CurrentScanLineNo) then Exit;

  Docs[ActivDocID].HideSelection;

  if Docs[ActivDocID].GetUndoCount = 1 then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled := False;
  end;
  if Docs[ActivDocID].GetRedoCount > -1 then begin
    ItRedoItem.Enabled := True;
    RedoBtn.Enabled := True;
  end;


  ItSave.Enabled := True;
  ItSaveAll.Enabled := True;
  SaveBtn.Enabled := True;
  SaveAllBtn.Enabled := True;

  Docs[ActivDocID].Undo;
end;

procedure TMainForm.ItRedoItemClick(Sender: TObject);
begin
  if not(Docs[ActivDocID].CaretPos.Y <= Docs[ActivDocID].CurrentScanLineNo) then Exit;
  Docs[ActivDocID].HideSelection;

  if Docs[ActivDocID].GetRedoCount = 1 then begin
    ItRedoItem.Enabled := False;
    RedoBtn.Enabled := False;
  end;
  if Docs[ActivDocID].GetUndoCount > -1 then begin
    ItUndoItem.Enabled := True;
    UndoBtn.Enabled := True;
  end;

  ItSave.Enabled := True;
  ItSaveAll.Enabled := True;
  SaveBtn.Enabled := True;
  SaveAllBtn.Enabled := True;

  Docs[ActivDocID].Redo;
end;

procedure TMainForm.ItSaveClick(Sender: TObject);
var
  i: Integer;
  flag: Boolean;
begin
  if Docs[ActivDocID].GetDocState = dsNew then begin
    ItSaveAs.Click;
  end;
  if Docs[ActivDocID].GetDocState = dsOpen then begin
    ItSave.Enabled := False;
    SaveBtn.Enabled := False;
    Docs[ActivDocID].SaveToFile(Docs[ActivDocID].GetDocPath);
    Docs[ActivDocID].CommitModify;
  end;

  flag := False;
  for i := 0 to Length(Docs) - 1 do begin
    if (Docs[i] <> nil) and (Docs[i].Modified) then flag := True;
  end;

  if not flag then begin
    ItSaveAll.Enabled := False;
    SaveAllBtn.Enabled := False;
  end;
end;

procedure TMainForm.ItSaveAsClick(Sender: TObject);
var
  i: Integer;
  flag: Boolean;
  NewFileName, Path: String;
begin
  SaveDialog.FilterIndex := Docs[ActivDocID].FilterIndex;
  NewFileName := Docs[ActivDocID].GetDocPath;
  Path := ExtractFilePath(NewFileName);

  case SaveDialog.FilterIndex of
    1: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.php';
    2: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.js';
    3: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.json';
    4: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.html';
    5: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.css';
    6: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.xml';
    7: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.txt';
    8: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '';
  end;

  SaveDialog.FileName := Path + NewFileName;

  if SaveDialog.Execute then begin
    ItSave.Enabled := False;
    SaveBtn.Enabled := False;
    Docs[ActivDocID].SaveToFile(SaveDialog.FileName);
    Docs[ActivDocID].SetDocPath(SaveDialog.FileName);
    Docs[ActivDocID].SetDocState(dsOpen);
    Docs[ActivDocID].CommitModify;
    TabControl.RenameTab(ActivDocID, ExtractFileName(SaveDialog.FileName));
    TabControl.Update;
    Caption := 'PHPNotepad - ' + SaveDialog.FileName;
  end;

  flag := False;
  for i := 0 to Length(Docs) - 1 do begin
    if (Docs[i] <> nil) and (Docs[i].Modified) then flag := True;
  end;

  if not flag then begin
    ItSaveAll.Enabled := False;
    SaveAllBtn.Enabled := False;
  end;
end;

procedure TMainForm.ItCloseClick(Sender: TObject);
var
  ID: Integer;
begin
  ID := ActivDocID;
  TabControl.CloseTab(ID);
  TabControl.Update;
end;
{------------------------------------------------------------------------------}
{------------------------------------------------------------------------------}
{------------------------------------------------------------------------------}
{------------------------------------------------------------------------------}
{------------------------------------------------------------------------------}
procedure TMainForm.SpeedButton2Click(Sender: TObject);
begin
  ShowMessage(IntToStr(Docs[ActivDocID].FScanFromLine));
end;

procedure TMainForm.SpeedButton3Click(Sender: TObject);
begin
  Docs[ActivDocID].FPaintBox.Repaint;
end;

procedure TMainForm.SpeedButton4Click(Sender: TObject);
begin
  ShowMessage(IntToStr(Docs[ActivDocID].FStringList.Count));
  ShowMessage(IntToStr(Length(Docs[ActivDocID].FLineStateAr)));
end;

procedure TMainForm.SpeedButton5Click(Sender: TObject);
begin
 { if Docs[ActivDocID].gS = Docs[ActivDocID].FStringList.Text then
    ShowMessage('True')
  else ShowMessage('False'); }
end;

procedure TMainForm.SpeedButton11Click(Sender: TObject);
begin
  Docs[ActivDocID].FScanFromLine := 0;
  Docs[ActivDocID].GoScan;
end;

procedure TMainForm.SpeedButton6Click(Sender: TObject);
begin
  Panel1.DoubleBuffered := True;
  Docs[ActivDocID].Test1;
end;

procedure TMainForm.SpeedButton1Click(Sender: TObject);
begin
  FormUR.ShowModal;
end;

procedure TMainForm.SpeedButton7Click(Sender: TObject);
begin
  if Docs[0].FStringList.Text = Docs[1].FStringList.Text  then ShowMessage('True')
  else ShowMessage('False');
end;

procedure TMainForm.ItSaveAllClick(Sender: TObject);
var
  i: Integer;
  flag: Boolean;
  NewFileName, Path: String;
begin
  flag := False;
  for i := 0 to Length(Docs) - 1 do begin
    if (Docs[i] <> nil) and (Docs[i].Modified) then begin
      if Docs[i].GetDocState = dsNew then begin

        SaveDialog.FilterIndex := Docs[i].FilterIndex;
        NewFileName := Docs[i].GetDocPath;
        Path := ExtractFilePath(NewFileName);

        case SaveDialog.FilterIndex of
          1: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.php';
          2: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.js';
          3: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.json';
          4: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.html';
          5: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.css';
          6: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.xml';
          7: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.txt';
          8: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '';
        end;

        SaveDialog.FileName := Path + NewFileName;

        if SaveDialog.Execute then begin
          ItSave.Enabled := False;
          SaveBtn.Enabled := False;
          Docs[i].SaveToFile(Path + NewFileName);
          Docs[i].SetDocPath(Path + NewFileName);
          Docs[i].SetDocState(dsOpen);
          Docs[i].CommitModify;
          TabControl.RenameTab(Docs[i].ID, ExtractFileName(NewFileName));
          TabControl.Update;
          Caption := 'PHPNotepad - ' + SaveDialog.FileName;
        end else begin
          ItSave.Enabled := True;
          SaveBtn.Enabled := True;
          flag := True;
        end;
      end;

      if Docs[i].GetDocState = dsOpen then begin
        ItSave.Enabled := False;
        SaveBtn.Enabled := False;
        Docs[i].SaveToFile(Docs[i].GetDocPath);
        Docs[i].CommitModify;
      end;
    end;
  end;

  if not flag then begin
    ItSaveAll.Enabled := False;
    SaveAllBtn.Enabled := False;
  end;
end;

procedure TMainForm.ItCloseAllClick(Sender: TObject);
var
  i, BtnSelID: Integer;
  SvFlags: array of Boolean;
  NewFileName, Path: String;
begin
  SetLength(SvFlags, Length(Docs));
  for i := 0 to Length(SvFlags) - 1 do begin
    SvFlags[i] := False;
  end;

  for i := 0 to Length(Docs) - 1 do begin
    if Docs[i] <> nil then begin
      if Docs[i].Modified then begin
        BtnSelID := MessageBox(Handle, PChar('Save file "'+Docs[i].GetDocPath+'" ?'), PChar('Save'), MB_YESNOCANCEL+MB_ICONQUESTION);

        if BtnSelID = mrCancel then begin
          Exit;
        end;

        if BtnSelID = mrYes then begin
          if Docs[i].GetDocState = dsOpen then begin
            Docs[i].SaveToFile(Docs[i].GetDocPath);
          end;
          if Docs[i].GetDocState = dsNew then begin
            SaveDialog.FilterIndex := Docs[i].FilterIndex;
            NewFileName := Docs[i].GetDocPath;
            Path := ExtractFilePath(NewFileName);

            case SaveDialog.FilterIndex of
              1: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.php';
              2: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.js';
              3: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.json';
              4: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.html';
              5: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.css';
              6: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.xml';
              7: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '.txt';
              8: NewFileName := StringReplace(ExtractFileName(NewFileName),ExtractFileExt(NewFileName),'',[]) + '';
            end;
            SaveDialog.FileName := Path + NewFileName;

            if SaveDialog.Execute then begin
              Docs[i].SaveToFile(Path + NewFileName);
              Docs[i].SetDocPath(Path + NewFileName);
              Docs[i].SetDocState(dsOpen);
              Docs[i].CommitModify;
              TabControl.RenameTab(Docs[i].ID, ExtractFileName(NewFileName));
              TabControl.Update;
              Caption := 'PHPNotepad - ' + SaveDialog.FileName;
            end;
          end;
        end;
        SvFlags[i] := True;
      end;
    end;
  end;

  for i := 0 to Length(SvFlags) - 1 do begin
    if SvFlags[i] then Docs[i].CommitModify;
  end;

  for i := 0 to Length(Docs) - 1 do begin
    if Docs[i] <> nil then begin
      TabControl.CloseTab(i);
    end;
  end;
  TabControl.Update;
end;

procedure TMainForm.SaveAllBtnClick(Sender: TObject);
begin
  ItSaveAll.Click;
end;

procedure TMainForm.CloseBtnClick(Sender: TObject);
begin
  ItClose.Click;
end;

procedure TMainForm.CloseAllBtnClick(Sender: TObject);
begin
  ItCloseAll.Click;
end;

procedure TMainForm.SaveDialogTypeChange(Sender: TObject);
var
  NewFileName: String;
begin
  case SaveDialog.FilterIndex of
    1: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.php';
    2: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.js';
    3: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.json';
    4: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.html';
    5: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.css';
    6: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.xml';
    7: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '.txt';
    8: NewFileName := StringReplace(ExtractFileName(SaveDialog.FileName),ExtractFileExt(SaveDialog.FileName),'',[]) + '';
  end;

  SendMessage(Windows.Getparent(Savedialog.Handle), CDM_SETCONTROLTEXT, 1152,
              Longint(PChar(NewFileName)));
end;

procedure TMainForm.HTMLBTNClick(Sender: TObject);
begin
  ChangeScanMode(smHTML);
  Docs[ActivDocID].SetScanStartLine(0);
  Docs[ActivDocID].GoScan;
end;

procedure TMainForm.PHPBTNClick(Sender: TObject);
begin
  ChangeScanMode(smPHP);
  Docs[ActivDocID].SetScanStartLine(0);
  Docs[ActivDocID].GoScan;  
end;

procedure TMainForm.JSBTNClick(Sender: TObject);
begin
  ChangeScanMode(smJS);
  Docs[ActivDocID].SetScanStartLine(0);
  Docs[ActivDocID].GoScan;
end;

procedure TMainForm.CSSBTNClick(Sender: TObject);
begin
  ChangeScanMode(smCSS);
  Docs[ActivDocID].SetScanStartLine(0);
  Docs[ActivDocID].GoScan;
end;

procedure TMainForm.TXTBTNClick(Sender: TObject);
begin
  ChangeScanMode(smTXT);
  Docs[ActivDocID].SetScanStartLine(0);
  Docs[ActivDocID].GoScan;
end;

procedure TMainForm.XMLBTNClick(Sender: TObject);
begin
  ChangeScanMode(smXML);
  Docs[ActivDocID].SetScanStartLine(0);
  Docs[ActivDocID].GoScan;
end;

procedure TMainForm.ChangeScanMode(SelectScanMode: TScanMode);
begin
  case SelectScanMode of
    smNo: begin
      HTMLBTN.Down := False;
      PHPBTN.Down := False;
      JSBTN.Down := False;
      CSSBTN.Down := False;
      XMLBTN.Down := False;
      TXTBTN.Down := False;    
      HTMLBTN.Enabled := False;
      PHPBTN.Enabled := False;
      JSBTN.Enabled := False;
      CSSBTN.Enabled := False;
      XMLBTN.Enabled := False;
      TXTBTN.Enabled := False;
    end;
    smYes: begin
      HTMLBTN.Enabled := True;
      PHPBTN.Enabled := True;
      JSBTN.Enabled := True;
      CSSBTN.Enabled := True;
      XMLBTN.Enabled := True;
      TXTBTN.Enabled := True;
    end;
    smHTML: begin
      HTMLBTN.Down := True;
      Docs[ActivDocID].ScanMode := smHTML;
      Docs[ActivDocID].FilterIndex := 4;
    end;
    smPHP: begin
      PHPBTN.Down := True;
      Docs[ActivDocID].ScanMode := smPHP;
      Docs[ActivDocID].FilterIndex := 1;
    end;
    smJS: begin
      JSBTN.Down := True;
      Docs[ActivDocID].ScanMode := smJS;
      Docs[ActivDocID].FilterIndex := 2;
    end;
    smCSS: begin
      CSSBTN.Down := True;
      Docs[ActivDocID].ScanMode := smCSS;
      Docs[ActivDocID].FilterIndex := 5;
    end;
    smXML: begin
      XMLBTN.Down := True;
      Docs[ActivDocID].ScanMode := smXML;
      Docs[ActivDocID].FilterIndex := 6;
    end;    
    smTXT: begin
      TXTBTN.Down := True;
      Docs[ActivDocID].ScanMode := smTXT;
      Docs[ActivDocID].FilterIndex := 7;
    end;
  end;
end;

procedure TMainForm.ItExitClick(Sender: TObject);
var
  i: Integer;
begin
  ItCloseAll.Click;

  if TabControl.GetTabCount = 0 then begin
    for i := 0 to Length(Docs) - 1 do begin
      if Docs[i] <> nil then begin
        Docs[i].Terminate;
        DocCloseTimer[i].Enabled := True;
      end;
    end;

    CloseQueryTimer.Enabled := True;
  end;
end;

procedure TMainForm.CutBtnClick(Sender: TObject);
begin
  ItCut.Click;
end;

procedure TMainForm.CopyBtnClick(Sender: TObject);
begin
  ItCopy.Click;
end;

procedure TMainForm.PasteBtnClick(Sender: TObject);
begin
  ItPaste.Click;
end;

procedure TMainForm.SpeedButton8Click(Sender: TObject);
begin
  if Docs[ActivDocID].TextSelected then ShowMessage('True')
  else ShowMessage('False');
end;


procedure TMainForm.SpeedButton9Click(Sender: TObject);
begin
  ItReopen.Delete(0);
end;

procedure TMainForm.ItFindClick(Sender: TObject);
begin
  AboutBox.Close;
  ShortHelpForm.Close;

  Docs[ActivDocID].StopCursor;
  SearchForm.PHPEditor := Docs[ActivDocID];
  SearchForm.Caption := 'Find';
  SearchForm.PageControl.Pages[0].Show;
  SearchForm.Visible := True;
  Docs[ActivDocID].RunCursor;
end;

procedure TMainForm.ItReplaceClick(Sender: TObject);
begin
  AboutBox.Close;
  ShortHelpForm.Close;

  Docs[ActivDocID].StopCursor;
  SearchForm.PHPEditor := Docs[ActivDocID];
  SearchForm.Caption := 'Replace';
  SearchForm.PageControl.Pages[1].Show;
  SearchForm.Visible := True;
  Docs[ActivDocID].RunCursor;
end;

procedure TMainForm.FindBtnClick(Sender: TObject);
begin
  ItFind.Click;
end;

procedure TMainForm.ReplaceBtnClick(Sender: TObject);
begin
  ItReplace.Click;
end;

procedure TMainForm.ExitBtnClick(Sender: TObject);
begin
  ItExit.Click;
end;

procedure TMainForm.ItPrintClick(Sender: TObject);
begin
  Docs[ActivDocID].Print;
end;

procedure TMainForm.LicenseAgreeBoxClick(Sender: TObject);
var
  Reg: TRegistry;
  i: Integer;
begin
  Reg := TRegistry.Create;
  try
    try
      Reg.RootKey :=  HKEY_CURRENT_USER;
      Reg.OpenKey('Software\PHPNotepad',true);
      Reg.WriteInteger('ReadLicense', 1);
    except
    end;
  finally
    for i := 0 to MainMenu.Items.Count - 1 do begin
      MainMenu.Items[i].Enabled := True;
    end;

    ToolPanel.Enabled := True;
    ModeBar.Enabled := True;
    TabPanel.Enabled := True;
    LicensePanel.Visible := False;
    ReadLicense := 1;

    for i := 0 to Length(Docs) - 1 do begin
      if Docs[i] <> nil then begin
        TabControl.CloseTab(0);
      end;
    end;

    TabControl.Update;
    Reg.free;
  end;

  Refresh;
end;

procedure TMainForm.PrintBtnClick(Sender: TObject);
begin
  ItPrint.Click;
end;

procedure TMainForm.PHPNotepad1Click(Sender: TObject);
begin
  AboutBox.Close;
  SearchForm.Close;
  ShortHelpForm.Visible := True;
end;

procedure TMainForm.AboutClick(Sender: TObject);
begin
  ShortHelpForm.Close;
  SearchForm.Close;
  AboutBox.FormStyle := fsStayOnTop;
  AboutBox.Visible := True;
end;

procedure TMainForm.PageSeparatorClick(Sender: TObject);
var
  i: Integer;
begin
  if TMenuItem(Sender).Checked then begin
    ShowSepLine := False;
    TMenuItem(Sender).Checked := False;
    for i := 0 to Length(Docs) - 1 do begin
      if Docs[i] <> nil then begin
        Docs[i].SepLinePaint := False;
        Docs[i].Refresh;
      end;
    end;
  end
  else begin
    ShowSepLine := True;
    TMenuItem(Sender).Checked := True;
    for i := 0 to Length(Docs) - 1 do begin
      if Docs[i] <> nil then begin
        Docs[i].SepLinePaint := True;
        Docs[i].Refresh;
      end;
    end;
  end;
end;

procedure TMainForm.IttoANSIClick(Sender: TObject);
var
  Enb: Boolean;
begin
  Enb := ItUndoItem.Enabled;

  if Length(Docs) > 0 then begin
    if Docs[ActivDocID] <> nil then begin
      Docs[ActivDocID].TransCode('ANSI');
      ItANSI.Checked := True;
    end;
  end;

  if not Enb then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled  := False;
  end;
end;

procedure TMainForm.IttoUTF8Click(Sender: TObject);
var
  Enb: Boolean;
begin
  Enb := ItUndoItem.Enabled;

  if Length(Docs) > 0 then begin
    if Docs[ActivDocID] <> nil then begin
      Docs[ActivDocID].TransCode('UTF-8 BOM');
      ItUTF8.Checked := True;
    end;  
  end;

  if not Enb then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled  := False;
  end;
end;

procedure TMainForm.IttoUCS2BigEndianClick(Sender: TObject);
var
  Enb: Boolean;
begin
  Enb := ItUndoItem.Enabled;

  if Length(Docs) > 0 then begin
    if Docs[ActivDocID] <> nil then begin
      Docs[ActivDocID].TransCode('UCS-2 BE');
      ItUCSBigEndian.Checked := True;
    end;  
  end;

  if not Enb then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled  := False;
  end;  
end;

procedure TMainForm.IttoUCS2LittleEndianClick(Sender: TObject);
var
  Enb: Boolean;
begin
  Enb := ItUndoItem.Enabled;
  
  if Length(Docs) > 0 then begin
    if Docs[ActivDocID] <> nil then begin
      Docs[ActivDocID].TransCode('UCS-2 LE');
      ItUCS2LittleEndian.Checked := True;
    end;  
  end;

  if not Enb then begin
    ItUndoItem.Enabled := False;
    UndoBtn.Enabled  := False;
  end;  
end;

end.



