unit PHPEdit;

interface

uses
  Windows, Controls, Classes, Forms, ExtCtrls, Graphics, StdCtrls, Dialogs,
  Types, Messages, ClipBrd, Buttons, ComCtrls, Menus, Printers, Encoding,
  StringListUnicodeSupport;

type
  TDocState = (dsNew, dsOpen);

  TScanMode = (smPHP, smHTML, smJS, smCSS, smXML, smTXT, smNo, smYes);
  
  TState = (ScanNull, ScanNormal, ScanPHP, ScanSingleQuoted, ScanDoubleQuoted, ScanComment,
            ScanLineComment, ScanVar, ScanFunc, ScanReserv, ScanDigit,
            ScanPHPTag, ScanHTMLTag, ScanOpenHTML, ScanHTMLAttr, ScanCloseHTML,
            ScanDblQHTML, ScanSingQHTML, ScanHTMLComment, ScanHTMLHeader,
            ScanCSSTag, ScanOpenCSS, ScanDblQCSS, ScanSingQCSS, ScanCloseCSS,
            ScanCSSBody, ScanCSSAttr, ScanCSSVal, ScanCSSComment,
            ScanJSTag, ScanOpenJS, ScanDblQJS, ScanSingQJS, ScanCloseJS,
            ScanJSBody, ScanJSMetods, ScanJSObj, ScanJSProp, ScanJSReserv,
            ScanJSComment, ScanDblStringJS, ScanSingStringJS, ScanLineJSComment
            );

  TStateRecord = record
    Pos: array of TState;
    Max: Integer;
    J: array of Integer;
  end;

  TStateArray = array of TStateRecord;

  PReplaceRec = ^TReplaceRec;
  TReplaceRec = record
    X: Integer;
    Y: Integer;
    Mask: array of Char;
    Next: PReplaceRec;
  end;

  TURType = (urUndo, urRedo);
  TActionType = (actInsert, actDelete, actReplace);
  TActionRecord = record
    ActType: TActionType;
    BeginPos: TPoint;
    EndPos: TPoint;
    Text: String;
    ReplText: String;
    RpBlock: Boolean;
    Ref: PReplaceRec;
  end;

  TDocPlaceInfo = record
    PlaceState: TState;
    DocSmType: TScanMode;
  end;

  TPHPEdit = class(TPanel)
  private
    FID: Integer;
    FLineHeight: Integer;

    FEndLine: Integer;
    FInDBlClick: Boolean;
    FTerminate: Boolean;
    FHorzScrollBar: TScrollBar;
    FHorzScrollPanel: TPanel;
    FScrollSeparator: TControl;
    FHorsStartPos: Integer;

    FCharWidth: Integer;
    predstate: TState;
    predj: Integer;
    DCount: Integer;

    FFonColor: TColor;

    FBigStringPartLen: Integer;

    FSelectedRange: array[0..1] of TPoint;

    //FRepaintTimer: TTimer;
    FRepaintWaitTimer: TTimer;
    FOpenTimer: TTimer;
    FDblClickTimer: TTimer;
    FCaretMerguTimer: TTimer;

    MergCounter: Integer;

    FMoveX: Integer;

    FUndoMenu: TMenuItem;
    FRedoMenu: TMenuItem;
    FSaveMenu: TMenuItem;
    FSaveAllMenu: TMenuItem;
    FCutMenu: TMenuItem;
    FCopyMenu: TMenuItem;
    FDeleteMenu: TMenuItem;
    FUndoBtn: TToolButton;
    FRedoBtn: TToolButton;
    FSaveBtn: TToolButton;
    FSaveAllBtn: TToolButton;
    FCutBtn: TToolButton;
    FCopyBtn: TToolButton;
    FEncodingMenu: TMenuItem;

    FpmCut: TMenuItem;
    FpmCopy: TMenuItem;
    FpmDelete: TMenuItem;
    FStatusBar: TStatusBar;
    FPrintDialog: TPrintDialog;

    FModified: Boolean;
    FDocPath: String;
    FDocState: TDocState;

    FScanMode: TScanMode;
    FFilterIndex: Integer;

    FPHPReservList: TStringList;
    FPHPFuncList: TStringList;
    FHtmlTagList: TStringList;
    FHtmlAttrList: TStringList;
    FHtmlMethodsList: TStringList;
    FJSObjectList: TStringList;
    FJSMethodsList: TStringList;
    FJSPropList: TStringList;
    FJSReservList: TStringList;
    FCSSAttrList: TStringList;
    FCSSValList: TStringList;
    
    FPerProcessMessages: Integer;
    FScreenAnchorBox: TControl;
    FSepLinePaint: Boolean;
    function GetCountOfDigit(Number: Integer): Integer;
    procedure CaretPaint;
    procedure SelectedRangePaint;
  public
    FRepaintTimer: TTimer;

    FStartLine: Integer;
    FCaretPos: TPoint;
    FSRMove: Boolean;
    FVertScrollBar: TScrollBar;

    FStringList: TStringList; FLineStateAr: TStateArray; FPaintBox: TPaintBox; FNumBox: TPaintBox;

    FUndoStack: array of TActionRecord;
    FRedoStack: array of TActionRecord;

    FStartSelected: Boolean;

    FScanFromLine: Integer;

    FMaxLineLength: Integer;

    FIndex: Integer;
    InScan: Boolean;

    gi,LineNo: Integer;
    gS: String;
    CurWord: String;
    LinePos: Integer;
    Next: Boolean;
    State: TState;
    ReturnState: TState;
    LastState: TState;

    FKeyChanged: Boolean;
    FBkChanged: Boolean;
    FDelChanged: Boolean;
    FKeyChgBeginPos: TPoint;
    FKeyChgEndPos: TPoint;
    FBkText: String;
    FUdText: String;

    procedure BeginKeyChanged(Ch: Char; CharPos: TPoint);
    procedure BeginBkSpaceChanged(Ch: Char; CharPos: TPoint);
    procedure BeginDelChanged(Ch: Char; CharPos: TPoint; Return: Boolean);

    procedure LoadFromFile(const FileName: String);
    procedure SaveToFile(const FileName: String);

    procedure VertScroll(Sender: TObject);
    procedure HorzScroll(Sender: TObject);
    procedure NumPaint(Sender: TObject);
    procedure Paint(Sender: TObject);
    procedure SetFon(Color: TColor);
    function GetSelectedText: String;
    procedure CopyToClipBoard;
    procedure CopyFromClipBoard;
    procedure ReCalcScrollRange;
    procedure HideSelection;
    procedure GoScan;
    procedure SetScanStartLine(LineN: Integer);
    procedure ValignWindowIfCursorHide;
    procedure AlignWindowIfCursorHide;
    function  TextSelected: Boolean;
    procedure CheckMaxLineLen(str: String);
    procedure ScanMaxLineLen;
    procedure InsertText;
    procedure DeleteText;
    procedure SetCursor(X,Y: Integer);
    function  GetVertScrollPos: Integer;
    procedure ScrollTo(Y: Integer);
    procedure SelectAll;
    procedure ActionAdd(AType: TActionType; BeginPos, EndPos: TPoint; Text, ReplText: String; RBlock: Boolean; Ref: PReplaceRec);
    procedure SwapUR(URType: TURType);
    procedure Undo;
    procedure Redo;
    procedure InsertTextBlock(Text: String; BeginY, BeginX: Integer);
    function DeleteTextBlock(BeginPos, EndPos: TPoint): String;
    procedure DeleteTx;
    procedure DeleteSelection;
    procedure DeleteChar;
    procedure Paste;
    procedure Cut;
    procedure SetSelection(SelFrom, SelTo: TPoint);
    function Find(str: String; FromCursor, CaseSens, FindForward: Boolean): Boolean;
    function CalcFind(str: String; FromCursor, CaseSens, FindForward: Boolean): Integer;
    function Replace(str, ReplaceText: String; FindForward, FromCursor, CaseSens: Boolean): Integer;
    function ReplaceAll(str, ReplaceText: String; FindForward, FromCursor, CaseSens: Boolean): Integer;

    procedure InsertWord(Word: String; PrefLen: Integer; Replace, Suffix: Boolean);
    procedure ScanAfterInsertWord;

    procedure AddState(var StateAr: TStateArray; LineN:Integer; State: TState; var NewPos: Integer; j: Integer);
    procedure ScanText(var StateAr: TStateArray);
    procedure ResetScaner(StartLine: Integer);

    procedure AssignMainMenu(UndoMenu, RedoMenu, SaveMenu, SaveAllMenu,
                             CutMenu, CopyMenu, DelMenu: TMenuItem;
                             UndoBtn, RedoBtn, SaveBtn, SaveAllBtn,
                             CutBtn, CopyBtn: TToolButton;
                             pmCutMenu, pmCopyMenu, pmDeleteMenu: TMenuItem;
                             sbStatusBar: TStatusBar; PrintDlg: TPrintDialog; SepLn: Boolean;
                             EncodeHead: TMenuItem);


    procedure AssignScanList(lsPHPReservList, lsPHPFuncList, lsHtmlTagList,
                             lsHtmlAttrList, lsHtmlMethodsList, lsJSObjectList, lsJSMethodsList,
                             lsJSPropList, lsJSReservList, lsCSSAttrList,
                             lsCSSValList: TStringList);
    procedure StopTimers;

    function Modified: Boolean;
    procedure CommitModify;
    procedure Modify;
    
    procedure SetDocPath(Path: String);
    function GetDocPath: String;
    function GetDocState: TDocState;
    procedure SetDocState(DocState: TDocState);

    function GetUndoCount: Integer;
    function GetRedoCount: Integer;

    procedure Terminate;

    procedure WheelDown(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure WheelUp(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    procedure CanResize(Sender: TObject; var NewWidth,
      NewHeight: Integer; var Resize: Boolean);
    procedure KeyPress(Sender: TObject; var Key: Char);
    procedure KeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    function IsCharPrint(Key: Char): Boolean;
    procedure DblClick(Sender: TObject);
    procedure Test1;
    procedure ProcRepaintTimer(Sender: TObject);
    procedure ProcRepaintWaitTimer(Sender: TObject);
    procedure ProcOpenTimer(Sender: TObject);
    procedure ProcDblClickTimer(Sender: TObject);
    procedure ProcCaretMerguTimer(Sender: TObject);
    function CreateScreenAnchorBox: Integer;
    procedure FreeScreenAnchorBox;
    function GetPref: String;
    function GetPlaceState: TDocPlaceInfo;
    function GetCaretChar: Char;
    procedure DecCaretX;
    function CurrentScanLineNo: Integer;
    procedure RunCursor;
    procedure StopCursor;
    procedure Print;
    procedure ShiftBlockLeft;
    procedure ShiftBlockRight;
    procedure ScrollLineUp;
    procedure ScrollLineDown;
    procedure TransCode(const Encoding: String);
    property ID: Integer read FID write FID;
    property CaretPos: TPoint read FCaretPos;
    property ScanMode: TScanMode read FScanMode write FScanMode;
    property FilterIndex: Integer read FFilterIndex write FFilterIndex;
    property ScreenAnchorBox: TControl read FScreenAnchorBox write FScreenAnchorBox;
    property SepLinePaint: Boolean read FSepLinePaint write FSepLinePaint;
    constructor Create(AOwner: TWinControl);
    destructor Destroy; override;
  end;

implementation

uses SysUtils, Main, DateUtils, StrUtils, TypInfo, WordBoxInit;

constructor TPHPEdit.Create(AOwner: TWinControl);
begin
  inherited Create(AOwner);
  Parent := AOwner;

  FFonColor := clWhite;

  FLineHeight := 17;
  FCharWidth := 8;
  FCaretPos.X := 1;
  FCaretPos.Y := 0;

  FStringList := TStringList.Create;
  FStringList.Add('');

  SetLength(FLineStateAr, 2);
  SetLength(FLineStateAr[0].Pos, 10);
  SetLength(FLineStateAr[0].J, 10);

  BevelOuter := bvLowered;
  Align := alClient;
  Color := FFonColor;
  Font.Name := 'Courier New';
  Font.Size := 10;
  DoubleBuffered := True;
  ControlStyle := ControlStyle + [csOpaque];

  FVertScrollBar := TScrollBar.Create(Self);
  FVertScrollBar.Parent := Self;
  FVertScrollBar.Kind := sbVertical;
  FVertScrollBar.Align := alRight;
  FVertScrollBar.OnChange := VertScroll;
  FVertScrollBar.TabStop := False;
  FVertScrollBar.Max := 1;
  FVertScrollBar.PageSize := 1;

  FHorzScrollPanel := TPanel.Create(Self);
  FHorzScrollPanel.Parent := Self;
  FHorzScrollPanel.Align := alBottom;
  FHorzScrollPanel.BevelOuter := bvNone;
  FHorzScrollPanel.Height := 17;

  FScrollSeparator := TControl.Create(FHorzScrollPanel);
  FScrollSeparator.Parent := FHorzScrollPanel;
  FScrollSeparator.Align := alRight;
  FScrollSeparator.Width := 17;
  FScrollSeparator.Height := 17;

  FHorzScrollBar := TScrollBar.Create(FHorzScrollPanel);
  FHorzScrollBar.Parent := FHorzScrollPanel;
  FHorzScrollBar.Kind := sbHorizontal;
  FHorzScrollBar.Align := alClient;
  FHorzScrollBar.OnChange := HorzScroll;
  FHorzScrollBar.TabStop := False;
  FHorzScrollBar.Max := 100;
  FHorzScrollBar.PageSize := 10;

  FNumBox := TPaintBox.Create(Self);
  FNumBox.Parent := Self;
  FNumBox.Align := alLeft;
  FNumBox.Width := 50;
  FNumBox.OnPaint := NumPaint;

  FPaintBox := TPaintBox.Create(Self);
  FPaintBox.Parent := Self;
  FPaintBox.ParentColor := false;
  FPaintBox.Align := alClient;
  FPaintBox.Cursor := crIBeam;
  FPaintBox.OnPaint := Paint;
  FPaintBox.OnMouseDown := MouseDown;
  FPaintBox.OnMouseMove := MouseMove;
  FPaintBox.OnMouseUp := MouseUp;
  FPaintBox.OnDblClick := DblClick;
  FPaintBox.Canvas.Pen.Mode := pmNotXor;

  FPaintBox.PopupMenu := MainForm.PopupMenu;

  OnCanResize := CanResize;
  Realign;
  predstate := ScanNormal;
  predj := 1;

  FRepaintTimer := TTimer.Create(nil);
  FRepaintTimer.Enabled := False;
  FRepaintTimer.Interval := 10;
  FRepaintTimer.OnTimer := ProcRepaintTimer;

  FRepaintWaitTimer := TTimer.Create(nil);
  FRepaintWaitTimer.Enabled := False;
  FRepaintWaitTimer.Interval := 500;
  FRepaintWaitTimer.OnTimer := ProcRepaintWaitTimer;

  FOpenTimer := TTimer.Create(nil);
  FOpenTimer.Enabled := False;
  FOpenTimer.Interval := 300;
  FOpenTimer.OnTimer := ProcOpenTimer;

  FDblClickTimer := TTimer.Create(nil);
  FDblClickTimer.Enabled := False;
  FDblClickTimer.Interval := 300;
  FDblClickTimer.OnTimer := ProcDblClickTimer;

  FCaretMerguTimer := TTimer.Create(nil);
  FCaretMerguTimer.Enabled := True;
  FCaretMerguTimer.Interval := 300;
  FCaretMerguTimer.OnTimer := ProcCaretMerguTimer;
  MergCounter := 0; 

  //FSRMove := False;
  
  Realign;
  FPaintBox.Repaint;
  FNumBox.Repaint;

  FKeyChanged := False;
  FBkChanged := False;
  FDelChanged := False;
  SetLength(FUndoStack,0);
  SetLength(FRedoStack,0);

  FModified := False;
  ReturnState := ScanNull;
  FBigStringPartLen := 512;
  FPerProcessMessages := 100;
  InScan := False;
end;

destructor TPHPEdit.Destroy;
var
  i, PtrCounter: Integer;
  NextPtr, DelPtr: PReplaceRec;
  PtrArray: array of Pointer;
begin
  FRepaintTimer.Free;
  FRepaintWaitTimer.Free;
  FOpenTimer.Free;
  FDblClickTimer.Free;
  FCaretMerguTimer.Free;

  FStringList.Free;
  SetLength(FLineStateAr,0);

  FPHPReservList := nil;
  FPHPFuncList := nil;
  FHtmlTagList := nil;
  FHtmlAttrList := nil;
  FJSObjectList := nil;
  FJSMethodsList := nil;
  FJSPropList := nil;
  FJSReservList := nil;
  FCSSAttrList := nil;
  FCSSValList := nil;

  {----------------------------------------------------------------------------}
  PtrCounter := 0;
  for i := 0 to Length(FUndoStack) - 1 do begin
    NextPtr := FUndoStack[i].Ref;
    while NextPtr <> nil do begin
      NextPtr := NextPtr^.Next;
      Inc(PtrCounter);
    end;
  end;

  SetLength(PtrArray, PtrCounter);
  PtrCounter := 0;
  for i := 0 to Length(FUndoStack) - 1 do begin
    NextPtr := FUndoStack[i].Ref;
    while NextPtr <> nil do begin
      PtrArray[PtrCounter] := NextPtr;
      NextPtr := NextPtr^.Next;
      Inc(PtrCounter);
    end;
  end;

  for i := 0 to Length(PtrArray) - 1 do begin
    SetLength(PReplaceRec(PtrArray[i])^.Mask, 0);
    Dispose(PtrArray[i]);
  end;

  SetLength(PtrArray, 0);
  SetLength(FUndoStack, 0);
  {----------------------------------------------------------------------------}
  PtrCounter := 0;
  for i := 0 to Length(FRedoStack) - 1 do begin
    NextPtr := FRedoStack[i].Ref;
    while NextPtr <> nil do begin
      NextPtr := NextPtr^.Next;
      Inc(PtrCounter);
    end;
  end;

  SetLength(PtrArray, PtrCounter);
  PtrCounter := 0;
  for i := 0 to Length(FRedoStack) - 1 do begin
    NextPtr := FRedoStack[i].Ref;
    while NextPtr <> nil do begin
      PtrArray[PtrCounter] := NextPtr;
      NextPtr := NextPtr^.Next;
      Inc(PtrCounter);
    end;
  end;

  for i := 0 to Length(PtrArray) - 1 do begin
    SetLength(PReplaceRec(PtrArray[i])^.Mask, 0);
    Dispose(PtrArray[i]);
  end;

  SetLength(PtrArray, 0);
  SetLength(FRedoStack, 0);
  {----------------------------------------------------------------------------}
  
  inherited Destroy;
end;

procedure TPHPEdit.AssignScanList(lsPHPReservList, lsPHPFuncList, lsHtmlTagList,
                                  lsHtmlAttrList, lsHtmlMethodsList, lsJSObjectList, lsJSMethodsList,
                                  lsJSPropList, lsJSReservList, lsCSSAttrList,
                                  lsCSSValList: TStringList);
begin
  FPHPReservList := lsPHPReservList;
  FPHPFuncList := lsPHPFuncList;
  FHtmlTagList := lsHtmlTagList;
  FHtmlAttrList := lsHtmlAttrList;
  FHtmlMethodsList := lsHtmlMethodsList;
  FJSObjectList := lsJSObjectList;
  FJSMethodsList := lsJSMethodsList;
  FJSPropList := lsJSPropList;
  FJSReservList := lsJSReservList;
  FCSSAttrList := lsCSSAttrList;
  FCSSValList := lsCSSValList;
end;


function TPHPEdit.GetDocPath: String;
begin
  Result := FDocPath;
end;

procedure TPHPEdit.SetDocPath(Path: String);
begin
  FDocPath := Path;
end;


function TPHPEdit.GetDocState: TDocState;
begin
  Result := FDocState;
end;

procedure TPHPEdit.SetDocState(DocState: TDocState);
begin
  FDocState := DocState;
end;

procedure TPHPEdit.AssignMainMenu(UndoMenu, RedoMenu, SaveMenu, SaveAllMenu,
                                  CutMenu, CopyMenu, DelMenu: TMenuItem;
                                  UndoBtn, RedoBtn, SaveBtn, SaveAllBtn,
                                  CutBtn, CopyBtn: TToolButton;
                                  pmCutMenu, pmCopyMenu, pmDeleteMenu: TMenuItem;
                                  sbStatusBar: TStatusBar; PrintDlg: TPrintDialog; SepLn: Boolean;
                                  EncodeHead: TMenuItem);
begin
  FUndoMenu := UndoMenu;
  FRedoMenu := RedoMenu;
  FUndoBtn := UndoBtn;
  FRedoBtn := RedoBtn;
  FSaveMenu := SaveMenu;
  FSaveAllMenu := SaveAllMenu;
  FSaveBtn := SaveBtn;
  FSaveAllBtn := SaveAllBtn;
  FCutBtn := CutBtn;
  FCopyBtn := CopyBtn;
  FCutMenu := CutMenu;
  FCopyMenu := CopyMenu;
  FDeleteMenu := DelMenu;
  FSepLinePaint := SepLn;
  FEncodingMenu := EncodeHead;
  {---------------------}
  FpmCut := pmCutMenu;
  FpmCopy := pmCopyMenu;
  FpmDelete := pmDeleteMenu;
  {---------------------}
  FStatusBar := sbStatusBar;
  FPrintDialog := PrintDlg;

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
  FStatusBar.Refresh;
end;

procedure TPHPEdit.StopTimers;
begin
  FRepaintTimer.Enabled := False;
  FRepaintWaitTimer.Enabled := False;
  FOpenTimer.Enabled := False;
  FDblClickTimer.Enabled := False;
  FCaretMerguTimer.Enabled := False;
end;

function TPHPEdit.Modified: Boolean;
begin
  Result := FModified;
end;

procedure TPHPEdit.CommitModify;
begin
  FModified := False;
end;

procedure TPHPEdit.Modify;
begin
  FModified := True;
  FUndoMenu.Enabled := True;
  FUndoBtn.Enabled := True;
  FSaveMenu.Enabled := True;
  FSaveBtn.Enabled := True;
  FSaveAllMenu.Enabled := True;
  FSaveAllBtn.Enabled := True;

  SetLength(FRedoStack,0);
  FRedoMenu.Enabled := False;
  FRedoBtn.Enabled := False;
end;

function TPHPEdit.GetUndoCount: Integer;
begin
  Result := Length(FUndoStack);
end;

function TPHPEdit.GetRedoCount: Integer;
begin
  Result := Length(FRedoStack);
end;

function TPHPEdit.CreateScreenAnchorBox: Integer;
begin
  FScreenAnchorBox := TControl.Create(Self);
  FScreenAnchorBox.Parent := Self;
  FScreenAnchorBox.Left := FCaretPos.X * FCharWidth;
  FScreenAnchorBox.Top := (FCaretPos.Y - FStartLine + 1) * FLineHeight;
  FScreenAnchorBox.Width := 0;
  FScreenAnchorBox.Height := 0;
  Result := FNumBox.Width;
end;

procedure TPHPEdit.FreeScreenAnchorBox;
begin
  FScreenAnchorBox.Free;
end;

function TPHPEdit.GetPref: String;
var
  i: Integer;
  str: String;
  Ch: Char;
begin
  for i := FCaretPos.X - 1 downto 1 do begin
    Ch := FStringList[FCaretPos.Y][i];
    if Ch in ['a'..'z','A'..'Z', '_', '-', ':'] then
      str := str + Ch
    else
      Break;
  end;

  Result := ReverseString(str);
end;

function TPHPEdit.GetPlaceState: TDocPlaceInfo;
var
  i,j: Integer;
  Br: Boolean;
  Ch: Char;
begin
  Result.PlaceState := ScanNull;
  Result.DocSmType := ScanMode;

  if (ScanMode <> smXML) and (ScanMode <> smTXT) then begin
    Br := False;
    for i := 1 to FLineStateAr[FCaretPos.Y].Max do begin
      for j := FLineStateAr[FCaretPos.Y].J[i-1] to FLineStateAr[FCaretPos.Y].J[i] - 1 do begin
        if j = FCaretPos.X - 1 then begin
          Result.PlaceState := FLineStateAr[FCaretPos.Y].Pos[i-1];
          if (Result.PlaceState = ScanDoubleQuoted) and (FCaretPos.X = FLineStateAr[FCaretPos.Y].J[i]) then  Result.PlaceState := ScanPHP;
          if (Result.PlaceState = ScanSingleQuoted) and (FCaretPos.X = FLineStateAr[FCaretPos.Y].J[i]) then  Result.PlaceState := ScanPHP;
          if (Result.PlaceState = ScanComment) and (FCaretPos.X = FLineStateAr[FCaretPos.Y].J[i]) then  Result.PlaceState := ScanPHP;

          if (Result.PlaceState = ScanSingQHTML) and (FCaretPos.X = FLineStateAr[FCaretPos.Y].J[i]) then  Result.PlaceState := ScanOpenHTML;
          if (Result.PlaceState = ScanDblQHTML) and (FCaretPos.X = FLineStateAr[FCaretPos.Y].J[i]) then  Result.PlaceState := ScanOpenHTML;

          if FLineStateAr[FCaretPos.Y].Pos[i] = ScanNormal then Result.PlaceState := ScanNormal;
          if FLineStateAr[FCaretPos.Y].Pos[i] = ScanCSSBody then Result.PlaceState := ScanCSSBody;
          if FLineStateAr[FCaretPos.Y].Pos[i] = ScanJSBody then Result.PlaceState := ScanJSBody;
          Br := True;
          Break;
        end;
      end;
      if Br then Break;
    end;
    if (FCaretPos.X = 1) and  (FLineStateAr[FCaretPos.Y].Pos[0] = ScanPHP) then  Result.PlaceState := ScanPHP;
    if (FCaretPos.X = 1) and  (FLineStateAr[FCaretPos.Y].Pos[0] = ScanNormal) then  Result.PlaceState := ScanNormal;
    if (FCaretPos.X = 1) and  (FLineStateAr[FCaretPos.Y].Pos[0] = ScanCSSBody) then  Result.PlaceState := ScanCSSBody;
    if (FCaretPos.X = 1) and  (FLineStateAr[FCaretPos.Y].Pos[0] = ScanJSBody) then  Result.PlaceState := ScanJSBody;
    //ScanCSSVal
    if Result.PlaceState = ScanCSSBody then begin
      for i := FCaretPos.X - 1 downto 1 do begin
        Ch := FStringList[FCaretPos.Y][i];
        if Ch in ['a'..'z','A'..'Z', '_', '-'] then
          //str := str + Ch
        else begin
          if Ch = ':' then Result.PlaceState := ScanCSSVal;
          Break;
        end;
      end;
    end;

  end;
end;

function TPHPEdit.GetCaretChar: Char;
begin
  if FCaretPos.X > 1 then
    Result := FStringList[FCaretPos.Y][FCaretPos.X-1];
end;

procedure TPHPEdit.DecCaretX;
begin
  Dec(FCaretPos.X);
  FPaintBox.Repaint;
end;

function TPHPEdit.CurrentScanLineNo: Integer;
begin
  Result := LineNo;
end;

procedure TPHPEdit.RunCursor;
begin
  FCaretMerguTimer.Enabled := True;
end;

procedure TPHPEdit.StopCursor;
begin
  FCaretMerguTimer.Enabled := False;
  if (MergCounter mod 2) <> 0  then Dec(MergCounter);
  FPaintBox.Repaint;
end;

procedure TPHPEdit.Print;
var
  Line: TextFile;
  i: integer;
begin
  if FPrintDialog.Execute then begin
    AssignPrn(Line);
    ReWrite(Line);
    Printer.Canvas.Font := Font;

    for i := 0 to FStringList.Count -1 do begin
      Writeln(Line, FStringList[i]);
    end;

    System.CloseFile(Line);
  end;
end;

procedure TPHPEdit.ShiftBlockLeft;
var
  BeginLine, EndLine, i: Integer;
  TLen, BLen: Integer;
  S: String;
  flag, modflag: Boolean;
  ReplTail, NextReplRtr: PReplaceRec;
begin
  if TextSelected then begin
    flag := False;
    if FSelectedRange[0].Y < FSelectedRange[1].Y then begin
      BeginLine := FSelectedRange[0].Y;
      EndLine := FSelectedRange[1].Y
    end else begin
      BeginLine := FSelectedRange[1].Y;
      EndLine := FSelectedRange[0].Y
    end;

    TLen := Length(FStringList[BeginLine]);
    BLen := Length(FStringList[EndLine]);

    for i := BeginLine to EndLine do begin
      S := FStringList[i];

      if Length(S) > 1 then begin
        if (S[1] = ' ') and (S[2] = ' ') then begin

          if not flag then begin
            New(ReplTail);
            ReplTail^.X := 1;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), '  ', '', True, ReplTail);
            flag := True;
          end else begin
            New(NextReplRtr);
            NextReplRtr^.X := 1;
            NextReplRtr^.Y := i;
            NextReplRtr^.Next := nil;
            ReplTail^.Next := NextReplRtr;
            ReplTail := NextReplRtr;
          end;

          Delete(S, 1, 2);
          modflag := True;
        end
        else if(S[1] = ' ') and (S[2] <> ' ') then begin

          if not flag then begin
            New(ReplTail);
            ReplTail^.X := 1;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), ' ', '', True, ReplTail);
            flag := True;
          end else begin
            New(NextReplRtr);
            NextReplRtr^.X := 1;
            NextReplRtr^.Y := i;
            NextReplRtr^.Next := nil;
            ReplTail^.Next := NextReplRtr;
            ReplTail := NextReplRtr;
          end;

          Delete(S, 1, 1);
          modflag := True;
        end;
      end;
      FStringList[i] := S;
    end;

    if FSelectedRange[0].Y = FSelectedRange[1].Y then begin
      Dec(FSelectedRange[0].X, TLen - Length(FStringList[BeginLine]));
      Dec(FSelectedRange[1].X, TLen - Length(FStringList[BeginLine]));
      Dec(FCaretPos.X, TLen - Length(FStringList[BeginLine]));
    end
    else if FSelectedRange[1].Y > FSelectedRange[0].Y then begin
      Dec(FSelectedRange[0].X, TLen - Length(FStringList[BeginLine]));
      Dec(FSelectedRange[1].X, BLen - Length(FStringList[EndLine]));
      if FCaretPos.Y = BeginLine then begin
        Dec(FCaretPos.X, TLen - Length(FStringList[BeginLine]));
      end;
      if FCaretPos.Y = EndLine then begin
        Dec(FCaretPos.X, BLen - Length(FStringList[EndLine]));
      end;
    end
    else if FSelectedRange[1].Y < FSelectedRange[0].Y then begin
      Dec(FSelectedRange[0].X, BLen - Length(FStringList[EndLine]));
      Dec(FSelectedRange[1].X, TLen - Length(FStringList[BeginLine]));
      if FCaretPos.Y = BeginLine then begin
        Dec(FCaretPos.X, TLen - Length(FStringList[BeginLine]));
      end;
      if FCaretPos.Y = EndLine then begin
        Dec(FCaretPos.X, BLen - Length(FStringList[EndLine]));
      end;      
    end;

    if FSelectedRange[0].X < 1 then FSelectedRange[0].X := 1;
    if FSelectedRange[1].X < 1 then FSelectedRange[1].X := 1;
    if FCaretPos.X < 1 then FCaretPos.X := 1;

    if modflag then Modify;

    FPaintBox.Repaint;
    ScanMaxLineLen;
    SetScanStartLine(BeginLine);
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    GoScan;
  end;
end;

procedure TPHPEdit.ShiftBlockRight;
var
  BeginLine, EndLine, i: Integer;
  TLen, BLen: Integer;
  S: String;
  flag, modflag: Boolean;
  ReplTail, NextReplRtr: PReplaceRec;
begin
  if TextSelected then begin
    flag := False;
    if FSelectedRange[0].Y < FSelectedRange[1].Y then begin
      BeginLine := FSelectedRange[0].Y;
      EndLine := FSelectedRange[1].Y
    end else begin
      BeginLine := FSelectedRange[1].Y;
      EndLine := FSelectedRange[0].Y
    end;

    TLen := Length(FStringList[BeginLine]);
    BLen := Length(FStringList[EndLine]);

    for i := BeginLine to EndLine do begin
      S := FStringList[i];

      if Length(S) > 0 then begin
        if not flag then begin
          New(ReplTail);
          ReplTail^.X := 1;
          ReplTail^.Y := i;
          ReplTail^.Next := nil;
          ActionAdd(actReplace, Point(0,0), Point(0,0), '', '  ', True, ReplTail);
          flag := True;
        end else begin
          New(NextReplRtr);
          NextReplRtr^.X := 1;
          NextReplRtr^.Y := i;
          NextReplRtr^.Next := nil;
          ReplTail^.Next := NextReplRtr;
          ReplTail := NextReplRtr;
        end;

        Insert('  ', S, 1);
        modflag := True;
      end;
      FStringList[i] := S;
    end;

   if FSelectedRange[0].Y = FSelectedRange[1].Y then begin
      Inc(FSelectedRange[0].X, Length(FStringList[BeginLine]) - TLen);
      Inc(FSelectedRange[1].X, Length(FStringList[BeginLine]) - TLen);
      Inc(FCaretPos.X, Length(FStringList[BeginLine]) - TLen);
    end
    else if FSelectedRange[1].Y > FSelectedRange[0].Y then begin
      Inc(FSelectedRange[0].X, Length(FStringList[BeginLine]) - TLen);
      Inc(FSelectedRange[1].X, Length(FStringList[EndLine]) - BLen);
      if FCaretPos.Y = BeginLine then begin
        Inc(FCaretPos.X, Length(FStringList[BeginLine]) - TLen);
      end;
      if FCaretPos.Y = EndLine then begin
        Inc(FCaretPos.X, Length(FStringList[EndLine]) - BLen);
      end;
    end
    else if FSelectedRange[1].Y < FSelectedRange[0].Y then begin
      Inc(FSelectedRange[0].X, Length(FStringList[EndLine]) - BLen);
      Inc(FSelectedRange[1].X, Length(FStringList[BeginLine]) - TLen);
      if FCaretPos.Y = BeginLine then begin
        Inc(FCaretPos.X, Length(FStringList[BeginLine]) - TLen);
      end;
      if FCaretPos.Y = EndLine then begin
        Inc(FCaretPos.X, Length(FStringList[EndLine]) - BLen);
      end;
    end;

    if modflag then Modify;

    FPaintBox.Repaint;
    ScanMaxLineLen;
    SetScanStartLine(BeginLine);
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    GoScan;
  end;
end;

procedure TPHPEdit.ScrollLineUp;
begin
  StopCursor;
  FVertScrollBar.Position := FVertScrollBar.Position - 1;
  if FVertScrollBar.Position + (FPaintBox.Height div FLineHeight) < FCaretPos.Y + 1 then begin
    FCaretPos.Y := FVertScrollBar.Position + (FPaintBox.Height div FLineHeight) - 1;
  end;
  FPaintBox.Repaint;
end;

procedure TPHPEdit.ScrollLineDown;
begin
  StopCursor;
  if FVertScrollBar.Position < FStringList.Count - 1 then begin
    FVertScrollBar.Position := FVertScrollBar.Position + 1;
  end;
  if FVertScrollBar.Position > FCaretPos.Y then begin
    FCaretPos.Y := FVertScrollBar.Position;
  end;
  FPaintBox.Repaint;  
end;

procedure TPHPEdit.TransCode(const Encoding: String);
var
  i: Integer;
begin
  FStringList.EncodingStr := Encoding;
  FStatusBar.Panels[2].Text := Encoding;

  Modify;  
  ReCalcScrollRange;
  ScanMaxLineLen;
  SetScanStartLine(0);
  GoScan;
end;

procedure TPHPEdit.DeleteTx;
var
  S: String;
begin
  if FSelectedRange[0].Y < FSelectedRange[1].Y then begin
    if not(FSelectedRange[0].Y <= LineNo) then Exit;
  end else begin
    if not(FSelectedRange[1].Y <= LineNo) then Exit;
  end;

  FCaretMerguTimer.Enabled := False;
  if (MergCounter mod 2) <> 0  then Dec(MergCounter);

  Modify;
  DeleteText;

  FCutMenu.Enabled := False;
  FCopyMenu.Enabled := False;
  FCutBtn.Enabled := False;
  FCopyBtn.Enabled := False;
  FDeleteMenu.Enabled := False;
  FpmCut.Enabled := False;
  FpmCopy.Enabled := False;
  FpmDelete.Enabled := False;

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
end;

procedure TPHPEdit.DeleteChar;
var
  S: String;
begin
  FSRMove := False;

  if FCaretPos.X <= Length(FStringList[FCaretPos.Y]) then begin
    Modify;

    BeginDelChanged(FStringList[FCaretPos.Y][FCaretPos.X], FCaretPos, False);

    S := FStringList[FCaretPos.Y];
    Delete(S, FCaretPos.X, 1);
    FStringList[FCaretPos.Y] := S;
  end else begin
    if FCaretPos.Y + 1 < FStringList.Count then begin
      Modify;
      BeginDelChanged(#0,FCaretPos,True);

      S := FStringList[FCaretPos.Y] + FStringList[FCaretPos.Y + 1];
      FStringList[FCaretPos.Y] := S;
      FStringList.Delete(FCaretPos.Y + 1);
    end else begin
      //тупик
      FPaintBox.Repaint;
    end;
  end;

  SetScanStartLine(FCaretPos.Y);
  SetLength(FLineStateAr, FStringList.Count + 1);
  ReCalcScrollRange;
  CheckMaxLineLen(S);
  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;
  GoScan;
end;

procedure TPHPEdit.Paste;
begin
  if not(CaretPos.Y <= LineNo) then Exit;

  Modify;
  if TextSelected then begin
    DeleteText;  
  end;
  InsertText;

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
end;

procedure TPHPEdit.Cut;
begin
  if FSelectedRange[0].Y < FSelectedRange[1].Y then begin
    if not(FSelectedRange[0].Y <= LineNo) then Exit;
    FStartLine := FSelectedRange[0].Y;
  end else begin
    if not(FSelectedRange[1].Y <= LineNo) then Exit;
    FStartLine := FSelectedRange[1].Y
  end;    

  SetScanStartLine(FStartLine);

  CopyToClipBoard;
  DeleteText;

  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;

  FCutMenu.Enabled := False;
  FCopyMenu.Enabled := False;
  FCutBtn.Enabled := False;
  FCopyBtn.Enabled := False;
  FDeleteMenu.Enabled := False;
  FpmCut.Enabled := False;
  FpmCopy.Enabled := False;
  FpmDelete.Enabled := False;

  Modify;
  HideSelection;

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
end;

procedure TPHPEdit.SetSelection(SelFrom, SelTo: TPoint);
begin
  FSelectedRange[0].X := SelFrom.X;
  FSelectedRange[0].Y := SelFrom.Y;
  FSelectedRange[1].X := SelTo.X;
  FSelectedRange[1].Y := SelTo.Y;
  FCaretPos.X := SelTo.X;
  FCaretPos.Y := SelTo.Y;

  AlignWindowIfCursorHide;
  ValignWindowIfCursorHide;

  FPaintBox.Repaint;
end;

function TPHPEdit.Find(str: String; FromCursor, CaseSens, FindForward: Boolean): Boolean;
var
  i: Integer;
  FindPos: Integer;
  Offset: Integer;
  flag: Boolean;
begin
  if str = '' then Exit;

  Offset := FCaretPos.X;
  flag := False;

  if FindForward then begin
    if CaseSens then begin
      if FromCursor then begin
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], Offset);

          if FindPos > 0 then begin
            SetSelection(Point(FindPos,i),Point(FindPos + Length(str),i));
            flag := True;
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], 1);
          if FindPos <> 0 then begin
            SetSelection(Point(FindPos,i),Point(FindPos + Length(str),i));
            flag := True;
            Break;
          end;
        end;
      end;
    end else begin
      if FromCursor then begin
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);

          if FindPos > 0 then begin
            SetSelection(Point(FindPos,i),Point(FindPos + Length(str),i));
            flag := True;
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), 1);
          if FindPos <> 0 then begin
            SetSelection(Point(FindPos,i),Point(FindPos + Length(str),i));
            flag := True;
            Break;
          end;
        end;
      end;
    end;
  end else begin   //bacward
    if CaseSens then begin
      if FromCursor then begin
        Offset := Length(FStringList[FCaretPos.Y]) + 2 - FCaretPos.X;
        for i := FCaretPos.Y downto 0 do begin
          FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            SetSelection(Point(FindPos + Length(str),i), Point(FindPos,i));
            flag := True;
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := FStringList.Count - 1 downto 0 do begin
          FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            SetSelection(Point(FindPos + Length(str),i), Point(FindPos,i));
            flag := True;
            Break;
          end;
          Offset := 1;
        end;
      end;
    end else begin //not CaseSens
      if FromCursor then begin
        Offset := Length(FStringList[FCaretPos.Y]) + 2 - FCaretPos.X;
        for i := FCaretPos.Y downto 0 do begin
          FindPos := PosEx(LowerCase(ReverseString(str)), LowerCase(ReverseString(FStringList[i])), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            SetSelection(Point(FindPos + Length(str),i), Point(FindPos,i));
            flag := True;
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := FStringList.Count - 1 downto 0 do begin
          FindPos := PosEx(LowerCase(ReverseString(str)), LowerCase(ReverseString(FStringList[i])), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            SetSelection(Point(FindPos + Length(str),i), Point(FindPos,i));
            flag := True;
            Break;
          end;
          Offset := 1;
        end;
      end;
    end;
  end;

  Result := flag;
end;

function TPHPEdit.CalcFind(str: String; FromCursor, CaseSens, FindForward: Boolean): Integer;
var
  i: Integer;
  FindPos: Integer;
  Offset: Integer;
  Counter: Integer;
begin
  if str = '' then Exit;

  Counter := 0;

  if FindForward then begin
    if CaseSens then begin
      if FromCursor then begin
        Offset := FCaretPos.X;
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(str, FStringList[i], Offset);
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(str, FStringList[i], Offset);
          end;
          Offset := 1;
        end;
      end;
    end else begin
      if FromCursor then begin
        Offset := FCaretPos.X;
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);
          end;
          Offset := 1;
        end;
      end;
    end;
  end else begin   //bacward
    if CaseSens then begin
      if FromCursor then begin
        Offset := Length(FStringList[FCaretPos.Y]) + 2 - FCaretPos.X;
        for i := FCaretPos.Y downto 0 do begin
          FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := FStringList.Count - 1 downto 0 do begin
          FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);
          end;
          Offset := 1;
        end;
      end;
    end else begin //not CaseSens
      if FromCursor then begin
        Offset := Length(FStringList[FCaretPos.Y]) + 2 - FCaretPos.X;
        for i := FCaretPos.Y downto 0 do begin
          FindPos := PosEx(ReverseString(LowerCase(str)), ReverseString(LowerCase(FStringList[i])), Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(ReverseString(ReverseString(str)), ReverseString(ReverseString(FStringList[i])), Offset);
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := FStringList.Count - 1 downto 0 do begin
          FindPos := PosEx(ReverseString(ReverseString(str)), ReverseString(ReverseString(FStringList[i])), Offset);
          while FindPos <> 0 do begin
            Inc(Counter);
            Offset := FindPos + Length(str);
            FindPos := PosEx(ReverseString(ReverseString(str)), ReverseString(ReverseString(FStringList[i])), Offset);
          end;
          Offset := 1;
        end;
      end;
    end;
  end;

  Result := Counter;
end;

function TPHPEdit.Replace(str, ReplaceText: String; FindForward, FromCursor, CaseSens: Boolean): Integer;
var
  i,j: Integer;
  FindPos: Integer;
  Offset: Integer;
  S, fnS: String;
  ReplTail: PReplaceRec;
begin
  if str = '' then Exit;

  Offset := FCaretPos.X;

  if FindForward then begin
    if CaseSens then begin
      if FromCursor then begin
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], Offset);

          if FindPos > 0 then begin
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos);}
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
                        
            FStringList[i] := S;
            SetSelection(Point(FindPos,i),Point(FindPos + Length(ReplaceText),i));
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], 1);

          if FindPos > 0 then begin
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos); }
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
                        
            FStringList[i] := S;
            SetSelection(Point(FindPos,i),Point(FindPos + Length(ReplaceText),i));
            Break;
          end;
          Offset := 1;
        end;
      end;
    end else begin
      if FromCursor then begin
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);

          if FindPos > 0 then begin
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos);}
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;

            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
                        
            FStringList[i] := S;
            SetSelection(Point(FindPos,i),Point(FindPos + Length(ReplaceText),i));
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), 1);

          if FindPos > 0 then begin
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos);}
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;
                          
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
                        
            FStringList[i] := S;
            SetSelection(Point(FindPos,i),Point(FindPos + Length(ReplaceText),i));
            Break;
          end;
          Offset := 1;
        end;
      end;
    end;
  end else begin   //backward
    if CaseSens then begin
      if FromCursor then begin
        Offset := Length(FStringList[FCaretPos.Y]) + 2 - FCaretPos.X;
        for i := FCaretPos.Y downto 0 do begin
          FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos);}
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);            

            FStringList[i] := S;
            SetSelection(Point(FindPos + Length(ReplaceText),i), Point(FindPos,i));
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := FStringList.Count - 1 downto 0 do begin
          FindPos := PosEx(ReverseString(str), ReverseString(FStringList[i]), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos);}
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
                        
            FStringList[i] := S;
            SetSelection(Point(FindPos + Length(ReplaceText),i), Point(FindPos,i));
            Break;
          end;
          Offset := 1;
        end;
      end;
    end else begin //not CaseSens
      if FromCursor then begin
        Offset := Length(FStringList[FCaretPos.Y]) + 2 - FCaretPos.X;
        for i := FCaretPos.Y downto 0 do begin
          FindPos := PosEx(LowerCase(ReverseString(str)), LowerCase(ReverseString(FStringList[i])), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos); }
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;

            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);

            FStringList[i] := S;
            SetSelection(Point(FindPos + Length(ReplaceText),i), Point(FindPos,i));
            Break;
          end;
          Offset := 1;
        end;
      end else begin
        Offset := 1;
        for i := FStringList.Count - 1 downto 0 do begin
          FindPos := PosEx(LowerCase(ReverseString(str)), LowerCase(ReverseString(FStringList[i])), Offset);

          if FindPos > 0 then begin
            FindPos := Length(FStringList[i]) - FindPos - Length(str) + 2;
            S := FStringList[i];
            {ActionAdd(actDelete, Point(FindPos,i), Point(FindPos + Length(str), i), Copy(S, FindPos, Length(str)), '', nil);
            Delete(S, FindPos, Length(str));
            ActionAdd(actInsert, Point(FindPos,i), Point(FindPos + Length(ReplaceText), i), ReplaceText, '', nil);
            Insert(ReplaceText, S, FindPos);}
            New(ReplTail);
            ReplTail^.X := FindPos;
            ReplTail^.Y := i;
            ReplTail^.Next := nil;
            ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
            fnS := Copy(S, FindPos, Length(str));

            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;

            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);

            FStringList[i] := S;
            SetSelection(Point(FindPos + Length(ReplaceText),i), Point(FindPos,i));
            Break;
          end;
          Offset := 1;
        end;
      end;
    end;
  end;

  Result := 1;

  Modify;
  SetScanStartLine(FCaretPos.Y);
  CheckMaxLineLen(FStringList[FCaretPos.Y]);
  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;
  GoScan;
end;

function TPHPEdit.ReplaceAll(str, ReplaceText: String; FindForward, FromCursor, CaseSens: Boolean): Integer;
var
  i,j: Integer;
  FindPos: Integer;
  Offset: Integer;
  S, STail, fnS: String;
  ReplCounter: Integer;
  flag: Boolean;
  ReplTail, NextReplRtr: PReplaceRec;
begin
  if str = '' then Exit;
  ReplCounter := 0;

  if FindForward then begin
    if CaseSens then begin
      if FromCursor then begin
        flag := False;
        Offset := FCaretPos.X;
        
        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], Offset);

          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            S := FStringList[i];
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(str, FStringList[i], Offset);
          end;

          Offset := 1;
        end;
      end else begin
        flag := False;
        Offset := 1;

        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(str, FStringList[i], Offset);

          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            S := FStringList[i];
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(str, FStringList[i], Offset);
          end;

          Offset := 1;
        end;
      end;
    end else begin //not CaseSens
      if FromCursor then begin
        flag := False;
        Offset := FCaretPos.X;

        for i := FCaretPos.Y to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);

          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            S := FStringList[i];

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;

            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);
          end;
          Offset := 1;
        end;
      end else begin
        flag := False;
        Offset := 1;

        for i := 0 to FStringList.Count - 1 do begin
          FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);

          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            S := FStringList[i];

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;
                        
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(LowerCase(str), LowerCase(FStringList[i]), Offset);
          end;

          Offset := 1;
        end;
      end;
    end;
  end else begin   //backward
    if CaseSens then begin
      if FromCursor then begin
        flag := False;
        Offset := 1;

        for i := 0 to FCaretPos.Y do begin
          if i = FCaretPos.Y then begin
            S := Copy(FStringList[i], 1, FCaretPos.X-1);
            STail := Copy(FStringList[i], FCaretPos.X, Length(S));
          end else
            S := FStringList[i];

          FindPos := PosEx(str, S, Offset);

          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(str, S, Offset);
          end;

          if i = FCaretPos.Y then
            FStringList[i] := S + STail;

          Offset := 1;
        end;
      end else begin
        flag := False;
        Offset := 1;

        for i := 0 to FStringList.Count - 1 do begin
          S := FStringList[i];
          FindPos := PosEx(str, S, Offset);
          
          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(LowerCase(str), S, Offset);
          end;

          FStringList[i] := S;
          Offset := 1;
        end;
      end;
    end else begin //not CaseSens
      if FromCursor then begin
        flag := False;
        Offset := 1;

        for i := 0 to FCaretPos.Y do begin
          if i = FCaretPos.Y then begin
            S := Copy(FStringList[i], 1, FCaretPos.X-1);
            STail := Copy(FStringList[i], FCaretPos.X, Length(S));
          end else
            S := FStringList[i];

          FindPos := PosEx(LowerCase(str), LowerCase(S), Offset);

          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;
                        
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(LowerCase(str), LowerCase(S), Offset);
          end;

          if i = FCaretPos.Y then
            FStringList[i] := S + STail;

          Offset := 1;
        end;
      end else begin
        flag := False;
        Offset := 1;

        for i := 0 to FStringList.Count - 1 do begin
          S := FStringList[i];
          FindPos := PosEx(LowerCase(str), LowerCase(S), Offset);
          
          while FindPos <> 0 do begin
            if not flag then begin
              New(ReplTail);
              ReplTail^.X := FindPos;
              ReplTail^.Y := i;
              ReplTail^.Next := nil;
              ActionAdd(actReplace, Point(0,0), Point(0,0), str, ReplaceText, False, ReplTail);
              flag := True;
            end else begin
              New(NextReplRtr);
              NextReplRtr^.X := FindPos;
              NextReplRtr^.Y := i;
              NextReplRtr^.Next := nil;
              ReplTail^.Next := NextReplRtr;
              ReplTail := NextReplRtr;
            end;

            fnS := Copy(S, FindPos, Length(str));
            if str <> fnS then begin
              SetLength(ReplTail^.Mask, Length(str));
              for j := 1 to Length(str) do begin
                if str[j] <> fnS[j] then begin
                  ReplTail^.Mask[j-1] := fnS[j];
                end else begin
                  ReplTail^.Mask[j-1] := #0;
                end;
              end;
            end;
                        
            Delete(S, FindPos, Length(str));
            Insert(ReplaceText, S, FindPos);
            FStringList[i] := S;

            Inc(ReplCounter);
            Offset := FindPos + Length(ReplaceText);
            FindPos := PosEx(LowerCase(str), LowerCase(S), Offset);
          end;

          FStringList[i] := S;
          Offset := 1;
        end;
      end;
    end;
  end;

  Result := ReplCounter;

  Modify;
  SetScanStartLine(0);
  ScanMaxLineLen;
  FPaintBox.Repaint;
  GoScan;
end;

procedure TPHPEdit.BeginKeyChanged(Ch: Char; CharPos: TPoint);
var
  TopIndex: Integer;
begin
  if (not FKeyChanged)  then begin
    FBkText := '';
    TopIndex := Length(FUndoStack);
    SetLength(FUndoStack, TopIndex + 1);
    FKeyChgBeginPos.X := CharPos.X;
    FKeyChgBeginPos.Y := CharPos.Y;
    FKeyChgEndPos.X := CharPos.X;
    FKeyChgEndPos.Y := CharPos.Y;
    FKeyChanged := True;
  end;

  if FKeyChanged then begin
    if ((CharPos.X) <> FKeyChgEndPos.X) or (CharPos.Y <> FKeyChgEndPos.Y {FKeyChgBeginPos.Y}) then begin
      FKeyChanged := False;
      BeginKeyChanged(Ch, CharPos);
    end else begin

      if Ch = #13 then begin
        FBkText := FBkText + #13#10;
        FKeyChgEndPos.X := 1;
        CharPos.X := 1;
        Inc(FKeyChgEndPos.Y);
      end else begin
        Inc(FKeyChgEndPos.X);
        FBkText := FBkText + Ch;
      end;
        
      TopIndex := Length(FUndoStack) - 1;
      FUndoStack[TopIndex].ActType := actInsert;
      FUndoStack[TopIndex].Text := FBkText;
      FUndoStack[TopIndex].BeginPos.X := FKeyChgBeginPos.X;
      FUndoStack[TopIndex].BeginPos.Y := FKeyChgBeginPos.Y;
      FUndoStack[TopIndex].EndPos.X := FKeyChgEndPos.X;
      FUndoStack[TopIndex].EndPos.Y := FKeyChgEndPos.Y;
    end;
  end;
end;

procedure TPHPEdit.BeginBkSpaceChanged(Ch: Char; CharPos: TPoint);
var
  TopIndex: Integer;
begin
  if not FBkChanged then begin
    FBkText := '';
    TopIndex := Length(FUndoStack);
    SetLength(FUndoStack, TopIndex + 1);
    FKeyChgBeginPos.X := CharPos.X;
    FKeyChgBeginPos.Y := CharPos.Y;
    FKeyChgEndPos.X := CharPos.X;
    FKeyChgEndPos.Y := CharPos.Y;
    FBkChanged := True;
  end;

  if FBkChanged then begin
    if (((CharPos.X) <> FKeyChgBeginPos.X) or (CharPos.Y <> FKeyChgBeginPos.Y)) then begin
      FBkChanged := False;
      BeginBkSpaceChanged(Ch, CharPos);
    end else begin

      if (Ch = #8) then begin
        Dec(FKeyChgBeginPos.Y);
        FKeyChgBeginPos.X := Length(FStringList[CharPos.Y-1]) + 1;
        FBkText := FBkText + #10#13;
      end else begin
        Dec(FKeyChgBeginPos.X);
        FBkText := FBkText + Ch;
      end;

      TopIndex := Length(FUndoStack) - 1;
      FUndoStack[TopIndex].ActType := actDelete;
      FUndoStack[TopIndex].Text := ReverseString(FBkText);
      FUndoStack[TopIndex].BeginPos.X := FKeyChgBeginPos.X;
      FUndoStack[TopIndex].BeginPos.Y := FKeyChgBeginPos.Y;
      FUndoStack[TopIndex].EndPos.X := FKeyChgEndPos.X;
      FUndoStack[TopIndex].EndPos.Y := FKeyChgEndPos.Y;
    end;
  end;
end;

procedure TPHPEdit.BeginDelChanged(Ch: Char; CharPos: TPoint; Return: Boolean);
var
  TopIndex: Integer;
begin
  if not FDelChanged then begin
    FBkText := '';
    TopIndex := Length(FUndoStack);
    SetLength(FUndoStack, TopIndex + 1);
    FKeyChgBeginPos.X := CharPos.X;
    FKeyChgBeginPos.Y := CharPos.Y;
    FKeyChgEndPos.X := CharPos.X;
    FKeyChgEndPos.Y := CharPos.Y;
    FDelChanged := True;
  end;

  if FDelChanged then begin
    if (((CharPos.X) <> FKeyChgBeginPos.X) or (CharPos.Y <> FKeyChgBeginPos.Y)) then begin
      FDelChanged := False;
      BeginDelChanged(Ch, CharPos, Return);
    end else begin
      if Return then begin
        Inc(FKeyChgEndPos.Y);
        FKeyChgEndPos.X := 1;
        FBkText := #10#13 + FBkText;
      end else begin
        Inc(FKeyChgEndPos.X);
        FBkText := Ch + FBkText;
      end;


      TopIndex := Length(FUndoStack) - 1;
      FUndoStack[TopIndex].ActType := actDelete;
      FUndoStack[TopIndex].Text := ReverseString(FBkText);
      FUndoStack[TopIndex].BeginPos.X := FKeyChgBeginPos.X;
      FUndoStack[TopIndex].BeginPos.Y := FKeyChgBeginPos.Y;
      FUndoStack[TopIndex].EndPos.X := FKeyChgEndPos.X;
      FUndoStack[TopIndex].EndPos.Y := FKeyChgEndPos.Y;
    end;
  end;
end;

procedure TPHPEdit.LoadFromFile(const FileName: String);
var
  i,j: Integer;
  s: String;
begin
  HideSelection;
  FCaretPos.X := 1;
  FCaretPos.Y := 0;

  FPaintBox.Repaint;
  FNumBox.Repaint;

  FStringList.LoadFromFile(FileName);
  FStatusBar.Panels[2].Text := FStringList.EncodingStr;

  if FStringList.EncodingStr = 'ANSI' then
    FEncodingMenu.Items[0].Checked := True
  else
  if FStringList.EncodingStr = 'UTF-8'then
    FEncodingMenu.Items[1].Checked := True
  else
  if FStringList.EncodingStr = 'UCS-2 BE'then
    FEncodingMenu.Items[2].Checked := True
  else
  if FStringList.EncodingStr = 'UCS-2 LE'then
    FEncodingMenu.Items[3].Checked := True;

  if FStringList.Count = 0 then FStringList.Add('');

  for i := 0 to FStringList.Count - 1 do begin
    FStringList[i] := StringReplace(FStringList[i], #9, '  ', [rfReplaceAll, rfIgnoreCase]);
  end;

  SetLength(FLineStateAr, FStringList.Count+1); {+1 при переносе if Ch = #10 then}
  FVertScrollBar.Position := 0;
  FHorzScrollBar.Position := 0;
  ScanMaxLineLen;
  ReCalcScrollRange;
  FVertScrollBar.Max := FStringList.Count;
  SetScanStartLine(0);

  if FStringList.Count > 0 then begin
    for i := 0 to FStringList.Count - 1 do begin
      SetLength(FLineStateAr[i].Pos, 10);
      SetLength(FLineStateAr[i].J, 10);
      FLineStateAr[i].Max := 0;
    end;
    FScanFromLine := 0;
    FOpenTimer.Enabled := True;
    GoScan;
  end;

  FNumBox.Repaint;
  Realign;
  FNumBox.Repaint;
end;

procedure TPHPEdit.SaveToFile(const FileName: String);
begin
  if FStringList.EncodingStr = 'ANSI' then
    FStringList.SaveToFile(FileName, TEncoding.Default)
  else if FStringList.EncodingStr = 'UTF-8 BOM' then begin
    FStringList.SaveToFile(FileName, TEncoding.UTF8)
  end else if FStringList.EncodingStr = 'UCS-2 LE' then
    FStringList.SaveToFile(FileName, TEncoding.Unicode)
  else if FStringList.EncodingStr = 'UCS-2 BE' then
    FStringList.SaveToFile(FileName, TEncoding.BigEndianUnicode)
end;

procedure TPHPEdit.GoScan;
begin
  if not FRepaintTimer.Enabled then FRepaintTimer.Enabled := True;
  if InScan then begin
    ResetScaner(FScanFromLine);
  end else begin
    ResetScaner(FScanFromLine);
    ScanText(FLineStateAr);
  end;
end;

procedure TPHPEdit.VertScroll(Sender: TObject);
var
  VisibleLineCount: Integer;
  i: Integer;
begin
  if (FVertScrollBar.Position > LineNo - (FEndLine - FStartLine)) and
     (FStringList.Count > (FVertScrollBar.Position + (FEndLine - FStartLine))) then begin
    FVertScrollBar.Position := LineNo;
    Exit;
  end;

  FStartLine := FVertScrollBar.Position;

  if (FStartLine + FPaintBox.ClientHeight div FLineHeight) < FStringList.Count then
    VisibleLineCount :=  FPaintBox.ClientHeight div FLineHeight + 1
  else
    VisibleLineCount := FStringList.Count - FStartLine;

  FEndLine := FStartLine + VisibleLineCount;

  FPaintBox.Repaint;
  FNumBox.Repaint;
end;

procedure TPHPEdit.HorzScroll(Sender: TObject);
begin
  FHorsStartPos := FHorzScrollBar.Position;
  FPaintBox.Repaint;
end;

procedure TPHPEdit.NumPaint(Sender: TObject);
var
  i,n: Integer;
begin
  FNumBox.Canvas.Brush.Color := clBtnFace;
  FNumBox.Canvas.FillRect(Rect(0,0,FNumBox.Width,FNumBox.Height));
  FNumBox.Canvas.Pen.Color := clSilver;
  FNumBox.Canvas.MoveTo(FNumBox.Width-1,0);
  FNumBox.Canvas.LineTo(FNumBox.Width-1,FNumBox.Height);

  FNumBox.Canvas.Font.Color := clGray;

  n := 1;

  for i := FStartLine to FEndLine - 1 do begin
    FNumBox.Canvas.TextOut(FNumBox.Width - 5 - GetCountOfDigit(i+1)*8,(n-1)*FLineHeight,IntToStr(i+1));
    Inc(n);
  end;
end;

procedure TPHPEdit.Paint(Sender: TObject);
var
  i,j,n: Integer;
  PredColor: TColor;
begin 
  n := 0;
  predstate := ScanNormal;

  for i := FStartLine to FEndLine - 1 do begin
    predj := 1;

    if Length(FLineStateAr[i].J) > 0 then
    for j := 0 to FLineStateAr[i].Max do begin

      if ((predj-FHorsStartPos) * FCharWidth) > FPaintBox.Width then Break;

      if (j+1) <= FLineStateAr[i].Max then begin
        if FLineStateAr[i].J[j+1] < FHorsStartPos then Continue;
      end;

      case predstate of
        ScanNormal:begin
          FPaintBox.Canvas.Font.Color := clBlack;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanPHP:begin
          FPaintBox.Canvas.Font.Color := clBlack;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanDoubleQuoted,
        ScanSingleQuoted,
        ScanDblStringJS,
        ScanSingStringJS:begin
          FPaintBox.Canvas.Font.Color := clGreen;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanComment,
        ScanLineComment:begin
          FPaintBox.Canvas.Font.Color := RGB(255,201,14);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanVar:begin
          FPaintBox.Canvas.Font.Color := RGB(75,75,75);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanReserv:begin
          FPaintBox.Canvas.Font.Style := [fsBold];
          FPaintBox.Canvas.Font.Color := clGreen;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
          FPaintBox.Canvas.Font.Style := [];
        end;
        ScanFunc:begin
          FPaintBox.Canvas.Font.Color := clBlue;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanDigit:begin
          FPaintBox.Canvas.Font.Color := clRed;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanPHPTag:begin
          FPaintBox.Canvas.Font.Style := [fsBold];
          FPaintBox.Canvas.Font.Color := clRed;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
          FPaintBox.Canvas.Font.Style := [];
        end;
        ScanHTMLTag:begin
          FPaintBox.Canvas.Font.Color := clMenuHighlight;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanHTMLAttr:begin
          FPaintBox.Canvas.Font.Color := RGB(128,128,0);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanOpenHTML,
        ScanOpenCSS,
        ScanOpenJS:begin
          FPaintBox.Canvas.Font.Color := clBlack;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanCloseHTML,
        ScanCloseCSS,
        ScanCloseJS:begin
          FPaintBox.Canvas.Font.Color := clBlack;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanDblQHTML,
        ScanSingQHTML,
        ScanDblQCSS,
        ScanSingQCSS,
        ScanDblQJS,
        ScanSingQJS:begin
          FPaintBox.Canvas.Font.Color := RGB(128,0,128);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanHTMLComment,
        ScanLineJSComment,
        ScanJSComment:begin
          FPaintBox.Canvas.Font.Color := clGray;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanHTMLHeader:begin
          FPaintBox.Canvas.Font.Color := clSkyBlue;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanCSSTag:begin
          FPaintBox.Canvas.Font.Color := RGB(255,122,0);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanCSSBody:begin
          FPaintBox.Canvas.Font.Style := [fsBold];
          FPaintBox.Canvas.Font.Color := clBlack;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
          FPaintBox.Canvas.Font.Style := [];
        end;
        ScanCSSAttr:begin
          FPaintBox.Canvas.Font.Style := [fsBold];
          FPaintBox.Canvas.Font.Color := RGB(155,53,255);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
          FPaintBox.Canvas.Font.Style := [];
        end;
        ScanCSSComment:begin
          FPaintBox.Canvas.Font.Color := clGray;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanJSTag:begin
          FPaintBox.Canvas.Font.Color := clRed;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanJSBody:begin
          FPaintBox.Canvas.Font.Color := clBlack;
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanJSReserv:begin
          FPaintBox.Canvas.Font.Style := [fsBold];
          FPaintBox.Canvas.Font.Color := RGB(0,0,117);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
          FPaintBox.Canvas.Font.Style := [];
        end;
        ScanJSObj:begin
          FPaintBox.Canvas.Font.Style := [fsBold];
          FPaintBox.Canvas.Font.Color := RGB(147,0,73);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
          FPaintBox.Canvas.Font.Style := [];
        end;
        ScanJSMetods:begin
          FPaintBox.Canvas.Font.Color := RGB(113,185,223);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
        ScanJSProp:begin
          FPaintBox.Canvas.Font.Color := RGB(0,0,170);
          FPaintBox.Canvas.TextOut((predj-FHorsStartPos)*FCharWidth,n*FLineHeight,Copy(FStringList[i],predj,FLineStateAr[i].J[j]-predj));
        end;
      end;

      predj := FLineStateAr[i].J[j];
      predstate := FLineStateAr[i].Pos[j];
    end;
    Inc(n);
  end;

  CaretPaint;
  SelectedRangePaint;

  if FSepLinePaint then begin
    FPaintBox.Canvas.Pen.Color := clSilver;
    FPaintBox.Canvas.MoveTo(FCharWidth*(81-FHorsStartPos),0);
    FPaintBox.Canvas.LineTo(FCharWidth*(81-FHorsStartPos),FPaintBox.Height);
  end;
end;

procedure TPHPEdit.Test1;
var
  SL: TStringList;
  i,j: Integer;
  s: String;
begin
  SL := TStringList.Create;
  MainForm.Memo1.Clear;
  for i := FStartLine to FEndLine do begin
    s := IntToStr(i+1) + '  {';
    for j := 0 to FLineStateAr[i].Max do begin
      case FLineStateAr[i].Pos[j] of


      ScanNull:begin
           s := s + 'ScanNull ,';
      end;
      ScanNormal:begin
           s := s + 'ScanNormal ,';
      end;
      ScanPHP:begin
           s := s + 'ScanPHP ,';
      end;
      ScanSingleQuoted:begin
           s := s + 'ScanSingleQuoted ,';
      end;
      ScanDoubleQuoted:begin
           s := s + 'ScanDoubleQuoted ,';
      end;
      ScanComment:begin
           s := s + 'ScanComment ,';
      end;
      ScanLineComment:begin
           s := s + 'ScanLineComment ,';
      end;
      ScanVar:begin
           s := s + 'ScanVar ,';
      end;
      ScanFunc:begin
           s := s + 'ScanFunc ,';
      end;
      ScanReserv:begin
           s := s + 'ScanReserv ,';
      end;
      ScanDigit:begin
           s := s + 'ScanDigit ,';
      end;
      ScanPHPTag:begin
           s := s + 'ScanPHPTag ,';
      end;
      ScanHTMLTag:begin
           s := s + 'ScanHTMLTag ,';
      end;
      ScanOpenHTML:begin
           s := s + 'ScanOpenHTML ,';
      end;
      ScanHTMLAttr:begin
           s := s + 'ScanHTMLAttr ,';
      end;
      ScanCloseHTML:begin
           s := s + 'ScanCloseHTML ,';
      end;
      ScanDblQHTML:begin
           s := s + 'ScanDblQHTML ,';
      end;
      ScanSingQHTML:begin
           s := s + 'ScanSingQHTML ,';
      end;
      ScanHTMLComment:begin
           s := s + 'ScanHTMLComment ,';
      end;
      ScanHTMLHeader:begin
           s := s + 'ScanHTMLHeader ,';
      end;
      ScanCSSTag:begin
           s := s + 'ScanCSSTag ,';
      end;
      ScanOpenCSS:begin
           s := s + 'ScanOpenCSS ,';
      end;
      ScanDblQCSS:begin
           s := s + 'ScanDblQCSS ,';
      end;
      ScanSingQCSS:begin
           s := s + 'ScanSingQCSS ,';
      end;
      ScanCloseCSS:begin
           s := s + 'ScanCloseCSS ,';
      end;
      ScanCSSBody:begin
           s := s + 'ScanCSSBody ,';
      end;
      ScanCSSAttr:begin
           s := s + 'ScanCSSAttr ,';
      end;
      ScanCSSComment:begin
           s := s + 'ScanCSSComment ,';
      end;
      ScanJSTag:begin
           s := s + 'ScanJSTag ,';
      end;
      ScanOpenJS:begin
           s := s + 'ScanOpenJS ,';
      end;
      ScanDblQJS:begin
           s := s + 'ScanDblQJS ,';
      end;
      ScanSingQJS:begin
           s := s + 'ScanSingQJS ,';
      end;
      ScanCloseJS:begin
           s := s + 'ScanCloseJS ,';
      end;
      ScanJSBody:begin
           s := s + 'ScanJSBody ,';
      end;
      ScanJSMetods:begin
           s := s + 'ScanJSMetods ,';
      end;
      ScanJSObj:begin
           s := s + 'ScanJSObj ,';
      end;
      ScanJSProp:begin
           s := s + 'ScanJSProp ,';
      end;
      ScanJSReserv:begin
           s := s + 'ScanJSReserv ,';
      end;
      ScanJSComment:begin
           s := s + 'ScanJSComment ,';
      end;
      ScanDblStringJS:begin
           s := s + 'ScanDblStringJS ,';
      end;
      ScanSingStringJS:begin
           s := s + 'ScanSingStringJS ,';
      end;
      ScanLineJSComment:begin
           s := s + 'ScanLineJSComment ,';
      end;
      ScanCSSVal:begin
           s := s + ' ScanCSSVal ,';
      end;

      end;
      s := s + 'J='+InttoStr(FLineStateAr[i].J[j])+' | ';
    end; 
    s := s + '}';
    MainForm.Memo1.Lines.Add(s);

  end;


end;

procedure TPHPEdit.SetFon(Color: TColor);
begin
//  FFon.Canvas.Brush.Color := clRed;
 // FFon.Canvas.FillRect(Rect(0,0,FNumBox.Width,FNumBox.Height));
end;

procedure TPHPEdit.WheelDown(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
  FVertScrollBar.Position := FVertScrollBar.Position + 1;
end;

procedure TPHPEdit.WheelUp(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
  FVertScrollBar.Position := FVertScrollBar.Position - 1;
end;

procedure TPHPEdit.CanResize(Sender: TObject; var NewWidth,
  NewHeight: Integer; var Resize: Boolean);
var
  VisibleLineCount: Integer;
begin
  FStartLine := FVertScrollBar.Position;

  if (FStartLine + FPaintBox.ClientHeight div FLineHeight) < FStringList.Count then
    VisibleLineCount :=  FPaintBox.ClientHeight div FLineHeight + 1
  else
    VisibleLineCount := FStringList.Count - FStartLine;

  FEndLine := FStartLine + VisibleLineCount;

  FVertScrollBar.LargeChange := (FEndLine - FStartLine);

  FPaintBox.Repaint;
  FNumBox.Repaint;
end;

function TPHPEdit.GetCountOfDigit(Number: Integer): Integer;
var
  Count: Integer;
begin
  Count := 0;
  while (Number <> 0) do begin
    Inc(Count);
    Number := Number div 10;
  end;

  Result := Count;
end;

procedure TPHPEdit.InsertWord(Word: String; PrefLen: Integer; Replace, Suffix: Boolean);
var
  S: String;
  i, DelBegin, DelEnd: Integer;
  flag: Boolean;
  ReplTail: PReplaceRec;
begin
  Modify;
  HideSelection;

  if Replace then begin
    DelBegin := FCaretPos.X - PrefLen;

    if Suffix then begin
      flag := False;
      for i := FCaretPos.X to Length(FStringList[FCaretPos.Y]) do begin
        if not (IsCharAlpha(FStringList[FCaretPos.Y][i]) or (FStringList[FCaretPos.Y][i] in ['_','-']))  then begin
          DelEnd := i;
          flag := True;
          Break;
        end;
      end;
      if not flag then
        DelEnd := Length(FStringList[FCaretPos.Y]) + 1;
        
    end else
      DelEnd := FCaretPos.X;

    S := FStringList[FCaretPos.Y];

    New(ReplTail);
    ReplTail^.X := DelBegin;
    ReplTail^.Y := FCaretPos.Y;
    ReplTail^.Next := nil;
    ActionAdd(actReplace, Point(0,0), Point(0,0), Copy(S, DelBegin, DelEnd - DelBegin), Word, False, ReplTail);
    Delete(S, DelBegin, DelEnd - DelBegin);
    Insert(Word, S, DelBegin);

    FStringList[FCaretPos.Y] := S;
    FCaretPos.X := DelBegin + Length(Word);
  end else begin
    S := FStringList[FCaretPos.Y];
    ActionAdd(actInsert, Point(FCaretPos.X, FCaretPos.Y), Point(FCaretPos.X + Length(Word), FCaretPos.Y), Word, '', False, nil);
    Insert(Word, S, FCaretPos.X);
    FStringList[FCaretPos.Y] := S;
    FCaretPos.X := FCaretPos.X  + Length(Word);
  end;

  ReCalcScrollRange;
  CheckMaxLineLen(FStringList[FCaretPos.Y]);
  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;
  GoScan;
end;

procedure TPHPEdit.ScanAfterInsertWord;
begin
  SetLength(FLineStateAr, FStringList.Count + 1);
  ReCalcScrollRange;
  SetScanStartLine(FVertScrollBar.Position);
  ScanMaxLineLen;
  GoScan;

  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;
end;

procedure TPHPEdit.KeyPress(Sender: TObject; var Key: Char);
var
  S, Space: String;
  i,j,spos,fpos: Integer;
begin
  SetScanStartLine(FCaretPos.Y);
  FSRMove := False;
  Modify;

  if TextSelected and not FStartSelected then begin
    DeleteSelection;
    SetLength(FLineStateAr, FStringList.Count + 1);
    ReCalcScrollRange;

    FCutMenu.Enabled := False;
    FCopyMenu.Enabled := False;
    FCutBtn.Enabled := False;
    FCopyBtn.Enabled := False;
    FpmCut.Enabled := False;
    FpmCopy.Enabled := False;
    FpmDelete.Enabled := False;
  end;

  if IsCharPrint(Key) then begin

    Space := '';

    if FCaretPos.X-1 > Length(FStringList[FCaretPos.Y]) then begin
      for i := 0 to FCaretPos.X-2 - Length(FStringList[FCaretPos.Y])  do
        Space := Space + ' ';
    end;

    S := FStringList[FCaretPos.Y];
    if Length(Space) > 0 then  S := S + Space;

    if Ord(Key) <> 9 then begin
      BeginKeyChanged(Key, FCaretPos);

      Insert(Key, S, Length(Space) + FCaretPos.X);
      FStringList[FCaretPos.Y] := S;
      Inc(FCaretPos.X);
    end else begin
      BeginKeyChanged(' ', FCaretPos);
      Inc(FCaretPos.X, 1);
      BeginKeyChanged(' ', FCaretPos);

      Insert('  ', S, Length(Space) + FCaretPos.X - 1);
      FStringList[FCaretPos.Y] := S;
      Inc(FCaretPos.X, 1);
    end;

    CheckMaxLineLen(S);
  end;

  if (Key <> #13) and (Key <> #8) then begin
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    GoScan;
  end;

  HideSelection;

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
  FStatusBar.Refresh; 
end;

procedure TPHPEdit.ProcRepaintTimer(Sender: TObject);
begin
  FPaintBox.Repaint;
  FNumBox.Repaint;
  FRepaintTimer.Enabled := False;
end;

procedure TPHPEdit.ProcRepaintWaitTimer(Sender: TObject);
begin
  FPaintBox.Repaint;
  FNumBox.Repaint;
  FRepaintWaitTimer.Enabled := False;
end;

procedure TPHPEdit.ProcDblClickTimer(Sender: TObject);
begin
  FDblClickTimer.Enabled := False;
end;

procedure TPHPEdit.ProcCaretMerguTimer(Sender: TObject);
begin
  Inc(MergCounter);

  if (MergCounter mod 2 = 0) then
    FPaintBox.Canvas.Pen.Color := clGreen
  else
    FPaintBox.Canvas.Pen.Color := FFonColor;

  FPaintBox.Canvas.MoveTo((FCaretPos.X-FHorsStartPos)*8,(FCaretPos.Y-FStartLine)*FLineHeight);
  FPaintBox.Canvas.LineTo((FCaretPos.X-FHorsStartPos)*8,(FCaretPos.Y-FStartLine)*FLineHeight+FLineHeight);
  FPaintBox.Canvas.MoveTo((FCaretPos.X-FHorsStartPos)*8-1,(FCaretPos.Y-FStartLine)*FLineHeight);
  FPaintBox.Canvas.LineTo((FCaretPos.X-FHorsStartPos)*8-1,(FCaretPos.Y-FStartLine)*FLineHeight+FLineHeight);
end;

procedure TPHPEdit.ProcOpenTimer(Sender: TObject);
begin
  FPaintBox.Repaint;
  FNumBox.Repaint;
  FOpenTimer.Enabled := False;
end;

function TPHPEdit.IsCharPrint(Key: Char): Boolean;
begin
  Result := False;
  if IsCharAlpha(Key) or (Key in ['0'..'9',' ','`','~','!','@','"','#','№','$',
                                  ';','%','^',':','&','?','*','(',')','-','_',
                                  '+','=','{','}','[',']','|','\','/','''',
                                  '<','>',',',#46])
                      or (Ord(Key) = 9)
  then Result := True;
end;

procedure TPHPEdit.DeleteSelection;
begin
  if TextSelected then begin
    if FSelectedRange[0].Y = FSelectedRange[1].Y then begin
       FStartLine := FSelectedRange[0].Y;
       SetScanStartLine(FStartLine);

      if FSelectedRange[0].X < FSelectedRange[1].X then
        ActionAdd(actDelete, FSelectedRange[0], FSelectedRange[1], DeleteTextBlock(FSelectedRange[0], FSelectedRange[1]), '', False, nil)
      else
        ActionAdd(actDelete, FSelectedRange[1], FSelectedRange[0], DeleteTextBlock(FSelectedRange[0], FSelectedRange[1]), '', False, nil);
    end else
    if FSelectedRange[0].Y < FSelectedRange[1].Y then begin
       FStartLine := FSelectedRange[0].Y;
       SetScanStartLine(FStartLine);
       ActionAdd(actDelete, FSelectedRange[0], FSelectedRange[1], DeleteTextBlock(FSelectedRange[0], FSelectedRange[1]), '', False, nil)
    end else begin
       FStartLine := FSelectedRange[1].Y;
       SetScanStartLine(FStartLine);
       ActionAdd(actDelete, FSelectedRange[1], FSelectedRange[0], DeleteTextBlock(FSelectedRange[0], FSelectedRange[1]), '', False, nil);
    end;
    HideSelection;
  end;
end;

procedure TPHPEdit.DeleteText;
begin
  DeleteSelection;
  SetLength(FLineStateAr, FStringList.Count + 1);
  ReCalcScrollRange;
  ScanMaxLineLen;
  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;  
  GoScan;
end;

procedure TPHPEdit.KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  i,spos,fpos: Integer;
  S, Space: String;
  NewCaretPos: TPoint;
begin
  SetScanStartLine(FCaretPos.Y-1); //-1 if BackSpace
  FCaretMerguTimer.Enabled := False;
  if (MergCounter mod 2) <> 0  then Dec(MergCounter);


  if Key = 17 then Exit;
  if Key <> 16 then FSRMove := False;

  if Key = 37 then begin
    if FCaretPos.X > 1 then Dec(FCaretPos.X)
    else if FCaretPos.Y > 0 then begin
      Dec(FCaretPos.Y);
      FCaretPos.X := Length(FStringList[FCaretPos.Y]) + 1;
    end;
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;    
    FPaintBox.Repaint;
  end;
  if Key = 39 then begin
    if FCaretPos.X <= Length(FStringList[FCaretPos.Y]) then Inc(FCaretPos.X)
    else if FCaretPos.Y < FStringList.Count - 1 then begin
      Inc(FCaretPos.Y);
      FCaretPos.X := 1;
    end;
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    FPaintBox.Repaint;
  end;
  if Key = 38 then begin
    if FCaretPos.Y > 0 then begin
      Dec(FCaretPos.Y);
      if FCaretPos.X > Length(FStringList[FCaretPos.Y]) then
        FCaretPos.X := Length(FStringList[FCaretPos.Y]) + 1;
    end;
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    FPaintBox.Repaint;
  end;
  if Key = 40 then begin
    if FCaretPos.Y < FStringList.Count-1 then begin
      Inc(FCaretPos.Y);
      if FCaretPos.X > Length(FStringList[FCaretPos.Y]) then
        FCaretPos.X := Length(FStringList[FCaretPos.Y]) + 1;
    end;
    
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    FPaintBox.Repaint;
  end;

  if Key = 8 then begin
    if TextSelected then begin
      Modify;
      DeleteSelection;
      SetLength(FLineStateAr, FStringList.Count + 1);
      ReCalcScrollRange;
      ScanMaxLineLen;
      GoScan;

      FCutMenu.Enabled := False;
      FCopyMenu.Enabled := False;
      FCutBtn.Enabled := False;
      FCopyBtn.Enabled := False;
      FpmCut.Enabled := False;
      FpmCopy.Enabled := False;
      FpmDelete.Enabled := False;
    end else begin
      if FCaretPos.X > 1 then begin
        Modify;
        if FCaretPos.X <= Length(FStringList[FCaretPos.Y]) + 1 then begin
          BeginBkSpaceChanged(FStringList[FCaretPos.Y][FCaretPos.X-1],FCaretPos);

          S := FStringList[FCaretPos.Y];
          Delete(S, FCaretPos.X-1, 1);
          FStringList[FCaretPos.Y] := S;
          ScanMaxLineLen;
        end;
    
        Dec(FCaretPos.X);
        ValignWindowIfCursorHide;
        AlignWindowIfCursorHide;
        GoScan;
      end else begin
        if FCaretPos.Y > 0 then begin
          Modify;
          BeginBkSpaceChanged(#8, FCaretPos);

          FCaretPos.X := Length(FStringList[FCaretPos.Y-1]) + 1;

          S := FStringList[FCaretPos.Y-1] + FStringList[FCaretPos.Y];
          FStringList[FCaretPos.Y-1] := S;
          CheckMaxLineLen(S);
          FStringList.Delete(FCaretPos.Y);
          FCaretPos.Y := FCaretPos.Y - 1;

          //на экран вниз
          if FCaretPos.Y < FStartLine then begin
             if FCaretPos.Y <> FVertScrollBar.Position then begin
               FVertScrollBar.Position := FVertScrollBar.Position - (FEndLine - FStartLine);
             end;
          end;

          SetLength(FLineStateAr, FStringList.Count + 1);
          ReCalcScrollRange;
          ValignWindowIfCursorHide;
          AlignWindowIfCursorHide;
          GoScan;
        end else begin
          //тупик
          FPaintBox.Repaint;
        end;
      end;
    end; //else TextSelected
  end;
       
  if Key = 13 then begin
    Modify;
    if TextSelected then begin
      DeleteSelection;

      FCutMenu.Enabled := False;
      FCopyMenu.Enabled := False;
      FCutBtn.Enabled := False;
      FCopyBtn.Enabled := False;
      FpmCut.Enabled := False;
      FpmCopy.Enabled := False;
      FpmDelete.Enabled := False;
    end;

    BeginKeyChanged(#13,FCaretPos);
    
    if FCaretPos.X <= Length(FStringList[FCaretPos.Y]) then begin
       S := FStringList[FCaretPos.Y];
       FStringList.Insert(FCaretPos.Y + 1, Copy(FStringList[FCaretPos.Y], FCaretPos.X, Length(S) - FCaretPos.X + 1));
       Delete(S, FCaretPos.X, Length(S) - FCaretPos.X + 1);
       FStringList[FCaretPos.Y] := S;

       FCaretPos.X := 1;
       FCaretPos.Y := FCaretPos.Y + 1;
    end else begin
       FStringList.Insert(FCaretPos.Y + 1,'');

       FCaretPos.X := 1;
       FCaretPos.Y := FCaretPos.Y + 1;
    end;

    SetLength(FLineStateAr, FStringList.Count + 1);
    ReCalcScrollRange;

    //на экран вверх
    if FCaretPos.Y > FEndLine-1 then begin
      if FVertScrollBar.Position < FStringList.Count - 1 then begin
         FVertScrollBar.Position := FVertScrollBar.Position + (FEndLine - FStartLine);
      end;
    end;

    ScanMaxLineLen;
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
    GoScan;
  end;

  if Key = 33 then begin
     if FVertScrollBar.Position - (FEndLine - FStartLine) > 0 then begin
       FVertScrollBar.Position := FVertScrollBar.Position - (FEndLine - FStartLine);
       FCaretPos.Y := FCaretPos.Y - (FEndLine - FStartLine);

       if ssShift in Shift then begin
         FSelectedRange[1].X := FCaretPos.X;
         FSelectedRange[1].Y := FCaretPos.Y;
       end;

     end else begin
       if ssShift in Shift then begin
         FCaretPos.X := 1;
         FCaretPos.Y := 0;

         FSelectedRange[1].X := FCaretPos.X;
         FSelectedRange[1].Y := FCaretPos.Y;
       end;
     end;

     ValignWindowIfCursorHide;
     AlignWindowIfCursorHide;
     FPaintBox.Repaint;
  end;

  if Key = 34 then begin
     if (FVertScrollBar.Position + (FEndLine - FStartLine)) < FStringList.Count then begin
       FVertScrollBar.Position := FVertScrollBar.Position + (FEndLine - FStartLine);
       FCaretPos.Y := FCaretPos.Y + (FEndLine - FStartLine);

       if ssShift in Shift then begin
         FSelectedRange[1].X := FCaretPos.X;
         FSelectedRange[1].Y := FCaretPos.Y;
       end;

     end else begin
       if ssShift in Shift then begin
         FCaretPos.X := Length(FStringList[FStringList.Count-1]) + 1;
         FCaretPos.Y := FStringList.Count - 1;

         FSelectedRange[1].X := FCaretPos.X;
         FSelectedRange[1].Y := FCaretPos.Y;
       end;
     end;

     ValignWindowIfCursorHide;
     AlignWindowIfCursorHide;
     FPaintBox.Repaint;
  end;

  if (not TextSelected) and (FStartSelected) then begin
    if Key = 16 then begin
      FSelectedRange[0].X := FCaretPos.X;
      FSelectedRange[0].Y := FCaretPos.Y;
      FSelectedRange[1].X := FCaretPos.X;
      FSelectedRange[1].Y := FCaretPos.Y;
      FStartSelected := True;
      FPaintBox.Repaint;
    end;
  end else begin
    if ssShift in Shift then begin
      if (Key = 37) or (Key = 38) or (Key = 39) or (Key = 40) then begin
        FSelectedRange[1].X := FCaretPos.X;
        FSelectedRange[1].Y := FCaretPos.Y;

          if TextSelected then begin
              FCutBtn.Enabled := True;
              FCopyBtn.Enabled := True;
              FCutMenu.Enabled := True;
              FCopyMenu.Enabled := True;
              FDeleteMenu.Enabled := True;
              FpmCut.Enabled := True;
              FpmCopy.Enabled := True;
              FpmDelete.Enabled := True;
          end else begin
              FCutBtn.Enabled := False;
              FCopyBtn.Enabled := False;
              FCutMenu.Enabled := False;
              FCopyMenu.Enabled := False;
              FDeleteMenu.Enabled := False;
              FpmCut.Enabled := False;
              FpmCopy.Enabled := False;
              FpmDelete.Enabled := False;
          end;

        FPaintBox.Repaint;
      end;
    end else begin      
      if (Key = 37) or (Key = 38) or (Key = 39) or (Key = 40)  then begin
         HideSelection;
         FPaintBox.Repaint;
         
         FCutMenu.Enabled := False;
         FCopyMenu.Enabled := False;
         FCutBtn.Enabled := False;
         FCopyBtn.Enabled := False;
         FpmCut.Enabled := False;
         FpmCopy.Enabled := False;
         FpmDelete.Enabled := False;
      end;
    end;
  end;

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
  FStatusBar.Refresh;
end;

procedure TPHPEdit.InsertText;
begin
  CopyFromClipBoard;
  SetLength(FLineStateAr, FStringList.Count + 1);
  ReCalcScrollRange;
  ScanMaxLineLen;
  ValignWindowIfCursorHide;
  AlignWindowIfCursorHide;
  GoScan;
end;

procedure TPHPEdit.KeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
begin
  FRepaintWaitTimer.Enabled := True;
  RunCursor;
end;

procedure TPHPEdit.CaretPaint;
begin
  FPaintBox.Canvas.Pen.Color := clGreen;
  FPaintBox.Canvas.MoveTo((FCaretPos.X-FHorsStartPos)*8,(FCaretPos.Y-FStartLine)*FLineHeight);
  FPaintBox.Canvas.LineTo((FCaretPos.X-FHorsStartPos)*8,(FCaretPos.Y-FStartLine)*FLineHeight+FLineHeight);
  FPaintBox.Canvas.MoveTo((FCaretPos.X-FHorsStartPos)*8-1,(FCaretPos.Y-FStartLine)*FLineHeight);
  FPaintBox.Canvas.LineTo((FCaretPos.X-FHorsStartPos)*8-1,(FCaretPos.Y-FStartLine)*FLineHeight+FLineHeight);
  FPaintBox.Canvas.Pen.Color := clBlack;
end;

procedure TPHPEdit.SelectedRangePaint;
var
  PredBrush, PredPen: TColor;
  i: Integer;
  Buf: Integer;
begin  
  PredBrush := FPaintBox.Canvas.Brush.Color;
  PredPen := FPaintBox.Canvas.Pen.Color;

  FPaintBox.Canvas.Brush.Color := RGB(200,243,210); //RGB(255,245,245);
  FPaintBox.Canvas.Pen.Color := RGB(200,243,210);  //RGB(255,245,245);

  if FSelectedRange[0].Y = FSelectedRange[1].Y then begin
    FPaintBox.Canvas.Rectangle((FSelectedRange[0].X-FHorsStartPos)*8,
                               (FSelectedRange[0].Y-FStartLine)*FLineHeight,
                               (FSelectedRange[1].X-FHorsStartPos)*8,
                               (FSelectedRange[1].Y-FStartLine)*FLineHeight + FLineHeight);
  end;

  if FSelectedRange[1].Y - FSelectedRange[0].Y >= 1 then begin
    FPaintBox.Canvas.Rectangle((FSelectedRange[0].X-FHorsStartPos)*8,
                               (FSelectedRange[0].Y-FStartLine)*FLineHeight,
                                FPaintBox.Width,
                               (FSelectedRange[0].Y-FStartLine)*FLineHeight + FLineHeight);
    FPaintBox.Canvas.Rectangle( 0,
                               (FSelectedRange[1].Y-FStartLine)*FLineHeight,
                               (FSelectedRange[1].X-FHorsStartPos)*8,
                               (FSelectedRange[1].Y-FStartLine)*FLineHeight + FLineHeight);
    FPaintBox.Canvas.Rectangle( 0,
                               ((FSelectedRange[0].Y)-FStartLine)*FLineHeight+FLineHeight,
                                FPaintBox.Width,
                               ((FSelectedRange[1].Y)-FStartLine)*FLineHeight);
  end;


  if FSelectedRange[1].Y - FSelectedRange[0].Y <= -1 then begin
    FPaintBox.Canvas.Rectangle( 0,
                               (FSelectedRange[0].Y-FStartLine)*FLineHeight,
                               (FSelectedRange[0].X-FHorsStartPos)*8,
                               (FSelectedRange[0].Y-FStartLine)*FLineHeight + FLineHeight);
    FPaintBox.Canvas.Rectangle((FSelectedRange[1].X-FHorsStartPos)*8,
                               (FSelectedRange[1].Y-FStartLine)*FLineHeight,
                                FPaintBox.Width,
                               (FSelectedRange[1].Y-FStartLine)*FLineHeight + FLineHeight);
    FPaintBox.Canvas.Rectangle( 0,
                               ((FSelectedRange[1].Y)-FStartLine)*FLineHeight+FLineHeight,
                                FPaintBox.Width,
                               ((FSelectedRange[0].Y)-FStartLine)*FLineHeight);
  end;

  FPaintBox.Canvas.Pen.Color := PredPen;
  FPaintBox.Canvas.Brush.Color := PredBrush;
end;

procedure TPHPEdit.MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
var
  i: Integer;
begin
  FCaretMerguTimer.Enabled := False;
  if (MergCounter mod 2) <> 0 then Dec(MergCounter);

  FKeyChanged := False;
  FDelChanged := False;
  FBkChanged  := False;

  if (ssLeft in Shift) then begin
    FCutBtn.Enabled := False;
    FCopyBtn.Enabled := False;
    FCutMenu.Enabled := False;
    FCopyMenu.Enabled := False;
    FDeleteMenu.Enabled := False;
    FpmCut.Enabled := False;
    FpmCopy.Enabled := False;
    FpmDelete.Enabled := False;
  end;

  FMoveX := X;

  if ssRight in Shift then begin
    Exit;
  end;

  if not FInDBlClick then begin

    FCaretPos.X := ((X+4) div 8) + FHorsStartPos;
    FCaretPos.Y := (Y div FLineHeight) + FStartLine;

    if FCaretPos.Y >= FStringList.Count then begin
      FCaretPos.Y := FStringList.Count - 1;
    end;

    if FCaretPos.X < 1 then FCaretPos.X := 1;

    if FCaretPos.X > Length(FStringList[FCaretPos.Y]) then begin
      FCaretPos.X := Length(FStringList[FCaretPos.Y]) + 1;
    end;

    FStartSelected := True;

    if not(ssShift in Shift) then begin
      FSelectedRange[0].X := FCaretPos.X;
      FSelectedRange[0].Y := FCaretPos.Y;
      FSelectedRange[1].X := FCaretPos.X;
      FSelectedRange[1].Y := FCaretPos.Y;
      FPaintBox.Repaint;
    end else begin
      FSelectedRange[1].X := FCaretPos.X;
      FSelectedRange[1].Y := FCaretPos.Y;
      FPaintBox.Repaint;
    end;
  end
    else FCaretPos.X := FSelectedRange[1].X;

  if FSelectedRange[0].X > Length(FStringList[FSelectedRange[0].Y]) then
    FSelectedRange[0].X := Length(FStringList[FSelectedRange[0].Y]) + 1;

  if FSelectedRange[1].X > Length(FStringList[FSelectedRange[1].Y]) then
    FSelectedRange[1].X := Length(FStringList[FSelectedRange[1].Y]) + 1;

  FSRMove := True;
  FPaintBox.Repaint;

  SetScanStartLine(FCaretPos.Y);

  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
  FStatusBar.Refresh;
end;

procedure TPHPEdit.MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  DownPos,n,i: Integer;
begin
 if FSRMove then begin
    FCaretPos.X := ((X+4) div 8) + FHorsStartPos;
    FCaretPos.Y := (Y div FLineHeight) + FStartLine;

    if X > FPaintBox.Width then begin
      FHorzScrollBar.Position := FHorzScrollBar.Position + 3;
    end;

    if X < 0 then begin
      FHorzScrollBar.Position := FHorzScrollBar.Position - 3;
    end;

    if FCaretPos.Y > FStringList.Count - 1 then begin
      FCaretPos.Y := FStringList.Count - 1;
    end;

    if FCaretPos.Y < 0 then begin
      FCaretPos.Y := 0;
    end;

    if FCaretPos.X < 1 then FCaretPos.X := 1;

    if FCaretPos.X > Length(FStringList[FCaretPos.Y]) then begin
      FCaretPos.X := Length(FStringList[FCaretPos.Y]) + 1;
    end;

   if (TextSelected or FStartSelected) then begin
     FSelectedRange[1].X := FCaretPos.X;
     FSelectedRange[1].Y := FCaretPos.Y;
   end;

    if Y > FPaintBox.Height then begin
      FVertScrollBar.Position := FVertScrollBar.Position + 3;
    end;
    if Y < 0 then begin
      FVertScrollBar.Position := FVertScrollBar.Position - 3;
    end;

    if FSelectedRange[0].X > Length(FStringList[FSelectedRange[0].Y]) then
      FSelectedRange[0].X := Length(FStringList[FSelectedRange[0].Y]) + 1;

    if FSelectedRange[1].X > Length(FStringList[FSelectedRange[1].Y]) then
      FSelectedRange[1].X := Length(FStringList[FSelectedRange[1].Y]) + 1;

    FPaintBox.Repaint;

    if TextSelected then begin
        FCutBtn.Enabled := True;
        FCopyBtn.Enabled := True;
        FCutMenu.Enabled := True;
        FCopyMenu.Enabled := True;
        FDeleteMenu.Enabled := True;
        FpmCut.Enabled := True;
        FpmCopy.Enabled := True;
        FpmDelete.Enabled := True;
    end else begin
        FCutBtn.Enabled := False;
        FCopyBtn.Enabled := False;
        FCutMenu.Enabled := False;
        FCopyMenu.Enabled := False;
        FDeleteMenu.Enabled := False;
        FpmCut.Enabled := False;
        FpmCopy.Enabled := False;
        FpmDelete.Enabled := False;
    end;

    SetScanStartLine(FCaretPos.Y);

    FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
    FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
    FStatusBar.Refresh;
  end;
end;

procedure TPHPEdit.MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  FCaretMerguTimer.Enabled := True;

  FSRMove := False;
  FInDBlClick := False;
  FStartSelected := False;

  if TextSelected then begin
      FCutBtn.Enabled := True;
      FCopyBtn.Enabled := True;
      FCutMenu.Enabled := True;
      FCopyMenu.Enabled := True;
      FDeleteMenu.Enabled := True;
      FpmCut.Enabled := True;
      FpmCopy.Enabled := True;
      FpmDelete.Enabled := True;
  end else begin
      FCutBtn.Enabled := False;
      FCopyBtn.Enabled := False;
      FCutMenu.Enabled := False;
      FCopyMenu.Enabled := False;
      FDeleteMenu.Enabled := False;
      FpmCut.Enabled := False;
      FpmCopy.Enabled := False;
      FpmDelete.Enabled := False;
  end;
end;

function TPHPEdit.GetSelectedText: String;
var
  i: Integer;
  s: String;
begin
  s := '';
  if FSelectedRange[0].Y = FSelectedRange[1].Y then begin
     if FSelectedRange[0].X <= FSelectedRange[1].X then begin
       s := Copy(FStringList[FSelectedRange[0].Y], FSelectedRange[0].X, FSelectedRange[1].X-FSelectedRange[0].X);
     end else begin
       s := Copy(FStringList[FSelectedRange[0].Y], FSelectedRange[1].X, FSelectedRange[0].X-FSelectedRange[1].X);
     end;
  end;

  if FSelectedRange[1].Y - FSelectedRange[0].Y >= 1 then begin
    s := s + Copy(FStringList[FSelectedRange[0].Y], FSelectedRange[0].X, Length(FStringList[FSelectedRange[0].Y]))+#13#10;
    for i := FSelectedRange[0].Y + 1 to FSelectedRange[1].Y - 1 do begin
      s := s + FStringList[i]+#13#10;
    end;
    s := s + Copy(FStringList[FSelectedRange[1].Y], 1, FSelectedRange[1].X-1);
  end;

  if FSelectedRange[1].Y - FSelectedRange[0].Y <= -1 then begin
    s := s + Copy(FStringList[FSelectedRange[1].Y], FSelectedRange[1].X, Length(FStringList[FSelectedRange[1].Y]))+#13#10;
    for i := FSelectedRange[1].Y + 1 to FSelectedRange[0].Y - 1 do begin
      s := s + FStringList[i]+#13#10;
    end;
    s := s + Copy(FStringList[FSelectedRange[0].Y], 1, FSelectedRange[0].X-1);
  end;

  Result := s;
end;

procedure TPHPEdit.CopyToClipBoard;
begin
  Clipboard.AsText := GetSelectedText;
end;

procedure TPHPEdit.InsertTextBlock(Text: String; BeginY, BeginX: Integer);
var
  i,n,spos,fpos,epos,len: Integer;
  StrCount: Integer;
  S,Space: String;
  BeginS, EndS: String;
  FullLines: array of String;
  BufText: String;
  BeginPos, EndPos: TPoint;
begin
  SetScanStartLine(FCaretPos.Y);

  StrCount := 0;

  BufText := Text;
  BufText := StringReplace(BufText, #9, '  ', [rfReplaceAll, rfIgnoreCase]);

  for i := 1 to Length(BufText) do begin
    if BufText[i] = #13 then begin
      Inc(StrCount);
    end;
  end;

  if (Length(BufText) > 0) and (StrCount = 0) then begin
    Space := '';

    if BeginX-1 > Length(FStringList[BeginY]) then begin
      for i := 0 to BeginX-2 - Length(FStringList[BeginY])  do
        Space := Space + ' ';
    end;

    S := FStringList[BeginY];
    if Length(Space) > 0 then  S := S + Space;
    Insert(BufText, S, Length(Space) + BeginX);
    FStringList[BeginY] := S;
    BeginX := BeginX + Length(BufText);
    FCaretPos.X := BeginX;
    FCaretPos.Y := BeginY;     
    
    CheckMaxLineLen(S);
  end;

  if StrCount = 1 then begin
    Space := '';

    if BeginX-1 > Length(FStringList[BeginY]) then begin
      for i := 0 to BeginX-2 - Length(FStringList[BeginY])  do
        Space := Space + ' ';
    end;

    for i := 1 to Length(BufText) do begin
      if BufText[i] = #13 then begin
        fpos := i-1;
        Break;
      end;
    end;
    BeginS := Copy(BufText,1,fpos);
    EndS := Copy(BufText,fpos+3,Length(BufText)-(fpos+2));
    len := Length(EndS);
    S := FStringList[BeginY];
    BeginS := Copy(S,1,BeginX-1) + Space + BeginS;
    EndS := EndS + Copy(S,(BeginX), Length(S));

    FStringList[BeginY] := BeginS;
    FStringList.Insert(BeginY+1, EndS);

    FCaretPos.Y := BeginY + 1;
    FCaretPos.X := len+1;
  end;

  if StrCount > 1 then begin
    SetLength(FullLines, StrCount-1);

    Space := '';

    if BeginX-1 > Length(FStringList[BeginY]) then begin
      for i := 0 to BeginX-2 - Length(FStringList[BeginY])  do
        Space := Space + ' ';
    end;

    for i := 1 to Length(BufText) do begin
      if BufText[i] = #13 then begin
        fpos := i-1;
        Break;
      end;
    end;
    BeginS := Copy(BufText,1,fpos);

    for i := Length(BufText) downto 1 do begin
      if BufText[i] = #10 then begin
        epos := i+1;
        Break;
      end;
    end;
    EndS := Copy(BufText,epos,Length(BufText)-(epos-1));

    n := 0;
    spos := fpos+3;
    for i := fpos+3 to epos do begin
      if i <= Length(BufText) then begin
        if BufText[i] = #13 then begin    //Range Out
           S := Copy(BufText,spos,i-spos);
           FullLines[n] := S;
           spos := i+2;
           Inc(n);
        end;
      end;
    end;

    //заливка в FStringList
    len := Length(EndS);
    S := FStringList[BeginY];
    BeginS := Copy(S,1,BeginX-1) + Space + BeginS;
    EndS := EndS + Copy(S,(BeginX), Length(S));

    FStringList[BeginY] := BeginS;

    n := 0;
    for i := 0 to Length(FullLines) - 1 do begin
      Inc(n);
      FStringList.Insert(BeginY + n, FullLines[i]);    
    end;

    Inc(n);
    FStringList.Insert(BeginY + n, EndS);

    SetLength(FLineStateAr,FStringList.Count + 1);

    FCaretPos.Y := BeginY + n;
    FCaretPos.X := len+1;

    SetLength(FullLines,0);
  end;
end;

function TPHPEdit.DeleteTextBlock(BeginPos, EndPos: TPoint): String;
var
  S: String;
  DeletedText, TopDeletedText, BottomDeletedText: String;
  BeginSelectedX, EndSelectedX: Integer;
  BeginSelectedY, EndSelectedY: Integer;
  i: Integer;
begin
  DeletedText := '';
  TopDeletedText := '';
  BottomDeletedText := '';

  if BeginPos.Y  = EndPos.Y then begin
    if BeginPos.X < EndPos.X then begin
      BeginSelectedX := BeginPos.X;
      EndSelectedX := EndPos.X;
    end else begin
      BeginSelectedX := EndPos.X;
      EndSelectedX := BeginPos.X;
    end;

    S := FStringList[BeginPos.Y];
    DeletedText := Copy(S, BeginSelectedX, EndSelectedX - BeginSelectedX);
    Delete(S, BeginSelectedX, EndSelectedX - BeginSelectedX);
    FStringList[BeginPos.Y] := S;

    FCaretPos.X := BeginSelectedX;
    FCaretPos.Y := BeginPos.Y; 
  end;

  if ABS(BeginPos.Y - EndPos.Y) >= 1 then begin
    if BeginPos.Y < EndPos.Y then begin
      S := FStringList[BeginPos.Y];
      TopDeletedText := Copy(S, BeginPos.X, Length(S) - BeginPos.X + 1) + #13#10;
      Delete(S, BeginPos.X, Length(S) - BeginPos.X + 1);
      FStringList[BeginPos.Y] := S;

      S := FStringList[EndPos.Y];
      BottomDeletedText := Copy(S, 1, EndPos.X - 1);
      Delete(S, 1, EndPos.X - 1);
      FStringList[EndPos.Y] := S;

      FStringList[BeginPos.Y] := FStringList[BeginPos.Y] + FStringList[EndPos.Y];
      FStringList.Delete(EndPos.Y);

      BeginSelectedX := BeginPos.X;
      BeginSelectedY := BeginPos.Y;
      EndSelectedX := EndPos.X;
      EndSelectedY := EndPos.Y;
    end else begin
      S := FStringList[EndPos.Y];
      TopDeletedText := Copy(S, EndPos.X, Length(S) - EndPos.X + 1) + #13#10;
      Delete(S, EndPos.X, Length(S) - EndPos.X + 1);
      FStringList[EndPos.Y] := S;

      S := FStringList[BeginPos.Y];
      BottomDeletedText := DeletedText + Copy(S, 1, BeginPos.X - 1);
      Delete(S, 1, BeginPos.X - 1);
      FStringList[BeginPos.Y] := S;

      FStringList[EndPos.Y] := FStringList[EndPos.Y] + FStringList[BeginPos.Y];
      FStringList.Delete(BeginPos.Y);

      BeginSelectedX := EndPos.X;
      BeginSelectedY := EndPos.Y;
      EndSelectedX := BeginPos.X;
      EndSelectedY := BeginPos.Y;
    end;

    for i := BeginSelectedY + 1 to EndSelectedY - 1 do begin
      DeletedText := DeletedText + FStringList[i] + #13#10;
    end;
    for i := EndSelectedY - 1 downto BeginSelectedY + 1 do begin
      FStringList.Delete(i);
    end;

    FCaretPos.X := BeginSelectedX;
    FCaretPos.Y := BeginSelectedY; 
  end;

  Result := TopDeletedText + DeletedText + BottomDeletedText;
end;

procedure TPHPEdit.CopyFromClipBoard;
var
  BufText: String;
  BeginPos: TPoint;
begin
  BufText := Clipboard.AsText;
  BufText := StringReplace(BufText, #9, '  ', [rfReplaceAll, rfIgnoreCase]);

  BeginPos.X := FCaretPos.X;
  BeginPos.Y := FCaretPos.Y;

  if LineNo < FCaretPos.Y then begin
    //добавить в очередь
  end else begin
    InsertTextBlock(Clipboard.AsText, FCaretPos.Y, FCaretPos.X);
    ActionAdd(actInsert, BeginPos, FCaretPos, BufText, '', False, nil);
  end;
end;


procedure TPHPEdit.ReCalcScrollRange;
var
  VisibleLineCount: Integer;
begin
  DCount := GetCountOfDigit(FStringList.Count);
  if DCount > 5 then
    FNumBox.ClientWidth := DCount * 8 + 10
  else
    FNumBox.ClientWidth := 50;

  FVertScrollBar.Max := FStringList.Count;
  FStartLine := FVertScrollBar.Position;

  if (FStartLine + FPaintBox.ClientHeight div FLineHeight) < FStringList.Count then
    VisibleLineCount :=  FPaintBox.ClientHeight div FLineHeight + 1
  else
    VisibleLineCount := FStringList.Count - FStartLine;

  FEndLine := FStartLine + VisibleLineCount;
end;

procedure TPHPEdit.SetCursor(X,Y: Integer);
begin
  FCaretPos.X := X;

  if Y <= (FStringList.Count - 1) then
    FCaretPos.Y := Y
  else begin
    if FStringList.Count - 2 >= 0 then begin
      FCaretPos.Y := FStringList.Count - 2;
    end;  
  end;
  AlignWindowIfCursorHide;
  FStatusBar.Panels[0].Text := ' Ln:' + IntToStr(FCaretPos.Y + 1);
  FStatusBar.Panels[1].Text := ' Col:' + IntToStr(FCaretPos.X);
  FStatusBar.Refresh; 
  FPaintBox.Repaint;
end;

procedure TPHPEdit.ScrollTo(Y: Integer);
begin
  FVertScrollBar.Position := Y;
  AlignWindowIfCursorHide;
  FPaintBox.Repaint;
end;

function TPHPEdit.GetVertScrollPos: Integer;
begin
  Result := FVertScrollBar.Position;
end;

procedure TPHPEdit.HideSelection;
begin
  FSelectedRange[0].X := FCaretPos.X;
  FSelectedRange[0].Y := FCaretPos.Y;
  FSelectedRange[1].X := FCaretPos.X;
  FSelectedRange[1].Y := FCaretPos.Y;
  FStartSelected := False;
end;

procedure TPHPEdit.SetScanStartLine(LineN: Integer);
var
  i: Integer;
begin
  if LineN > 0 then
    FScanFromLine := LineN - 1
  else
    FScanFromLine := 0;
end;

procedure TPHPEdit.ValignWindowIfCursorHide;
begin
  //Scroll Up
  if FCaretPos.Y < FStartLine then begin
   if FCaretPos.Y <> FVertScrollBar.Position then begin
     FVertScrollBar.Position := FCaretPos.Y;
   end;
  end;
  //Scroll Down
  if FCaretPos.Y > FStartLine + (FPaintBox.Height div FLineHeight) - 1 then begin
   if FVertScrollBar.Position < FStringList.Count - 1 then begin
     FVertScrollBar.Position := FCaretPos.Y - (FPaintBox.Height div FLineHeight) + 1;
    end;
  end;
end;

procedure TPHPEdit.AlignWindowIfCursorHide;
begin
  //Scroll Left
  if FCaretPos.X <= FHorsStartPos then begin
     FHorzScrollBar.Position := FCaretPos.X - 2;
  end;
  //Scroll Right
  if FCaretPos.X > FHorsStartPos + FPaintBox.Width div 8 then begin
     FHorzScrollBar.Position := FCaretPos.X  - (FPaintBox.Width div 8 - 5);
  end;
end;

function TPHPEdit.TextSelected: Boolean;
begin
  if ((FSelectedRange[0].X - FSelectedRange[1].X) <> 0) or
     ((FSelectedRange[0].Y - FSelectedRange[1].Y) <> 0) {or FStartSelected} then
    Result := True
  else
    Result := False;
end;

procedure TPHPEdit.SelectAll;
begin
  FSelectedRange[0].X := 1;
  FSelectedRange[0].Y := 0;
  FSelectedRange[1].X := Length(FStringList[FStringList.Count - 1]) + 1;
  FSelectedRange[1].Y := FStringList.Count - 1;
  FCaretPos.X := Length(FStringList[FStringList.Count - 1]) + 1;
  FCaretPos.Y := FStringList.Count - 1;

  FCutBtn.Enabled := True;
  FCopyBtn.Enabled := True;
  FCutMenu.Enabled := True;
  FCopyMenu.Enabled := True;
  FDeleteMenu.Enabled := True;
  FpmCut.Enabled := True;
  FpmCopy.Enabled := True;
  FpmDelete.Enabled := True;

  FPaintBox.Repaint;
end;

procedure TPHPEdit.DblClick(Sender: TObject);
var
  i: Integer;
  Ch: Char;
  FirstChar: Boolean;
begin
  if Length(FStringList[FCaretPos.Y]) > 0 then begin
    //select word
    if FCaretPos.X <= Length(FStringList[FCaretPos.Y]) then begin
      Ch := FStringList[FCaretPos.Y][FCaretPos.X];
      if (IsCharAlpha(Ch) or (Ch in ['0'..'9','_']))  then begin

        for i := FCaretPos.X downto 1 do begin
          Ch := FStringList[FCaretPos.Y][i];
          if not (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
            FSelectedRange[0].X := i+1;
            FSelectedRange[0].Y := FCaretPos.Y;
            Break;
          end;
          if (i = 1) then begin
            FSelectedRange[0].X := i;
            FSelectedRange[0].Y := FCaretPos.Y;
          end;
        end;

        for i := FCaretPos.X to Length(FStringList[FCaretPos.Y]) do begin
          Ch := FStringList[FCaretPos.Y][i];
          if not (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
            FSelectedRange[1].X := i;
            FSelectedRange[1].Y := FCaretPos.Y;
            Break;
          end;
          if (i = Length(FStringList[FCaretPos.Y])) then begin
            FSelectedRange[1].X := i+1;
            FSelectedRange[1].Y := FCaretPos.Y;
          end;
        end;

      end else begin
        FirstChar := False;

        for i := FCaretPos.X downto 1 do begin
          Ch := FStringList[FCaretPos.Y][i];
          if not FirstChar and (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
            FirstChar := True;
            FSelectedRange[1].X := i+1;
            FSelectedRange[1].Y := FCaretPos.Y;
          end;

          if FirstChar and not (IsCharAlpha(Ch) or (Ch in ['0'..'9','_']))  then begin
            FSelectedRange[0].X := i+1;
            FSelectedRange[0].Y := FCaretPos.Y;
            Break;
          end;

          if FirstChar and (i=1) then begin
            FSelectedRange[0].X := i;
            FSelectedRange[0].Y := FCaretPos.Y;
            Break;
          end;
        end;

        if (FSelectedRange[1].X - FSelectedRange[0].X = 0) then begin
          FirstChar := False;

          for i := FSelectedRange[1].X to Length(FStringList[FCaretPos.Y])  do begin
            Ch := FStringList[FCaretPos.Y][i];
            if not FirstChar and (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
              FirstChar := True;
              FSelectedRange[0].X := i;
              FSelectedRange[0].Y := FCaretPos.Y;
            end;

            if FirstChar and not (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
              FSelectedRange[1].X := i;
              FSelectedRange[1].Y := FCaretPos.Y;
              Break;
            end;

            if FirstChar and (i=Length(FStringList[FCaretPos.Y])) then begin
              FSelectedRange[1].X := i+1;
              FSelectedRange[1].Y := FCaretPos.Y;
              Break;
            end;
          end;
        end;
      end;
    end;
    //end select word

    if FCaretPos.X > Length(FStringList[FCaretPos.Y]) then begin
      FirstChar := False;

      for i := Length(FStringList[FCaretPos.Y]) downto 1 do begin
        Ch := FStringList[FCaretPos.Y][i];
        if not FirstChar and (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
          FirstChar := True;
          FSelectedRange[1].X := i+1;
          FSelectedRange[1].Y := FCaretPos.Y;
        end;

        if FirstChar and not (IsCharAlpha(Ch) or (Ch in ['0'..'9','_'])) then begin
          FSelectedRange[0].X := i+1;
          FSelectedRange[0].Y := FCaretPos.Y;
          Break;
        end;

        if FirstChar and (i=1) then begin
          FSelectedRange[0].X := i;
          FSelectedRange[0].Y := FCaretPos.Y;
          Break;
        end;
      end;
    end;
    if (FSelectedRange[1].X - FSelectedRange[0].X = 0) then begin
      FSelectedRange[0].X := 1;
      FSelectedRange[0].Y := FCaretPos.Y;
      FSelectedRange[1].X := Length(FStringList[FCaretPos.Y]) + 1;
      FSelectedRange[1].Y := FCaretPos.Y;
    end;
  end;

  FInDBlClick := True;
  FPaintBox.Repaint;
end;

procedure TPHPEdit.CheckMaxLineLen(str: String);
begin
  if Length(str) > FMaxLineLength then begin
    FMaxLineLength := Length(str);
    FHorzScrollBar.Max :=FMaxLineLength + 1 + FHorzScrollBar.PageSize;
  end;
end;

procedure TPHPEdit.ScanMaxLineLen;
var
  i: Integer;
begin
  FMaxLineLength := 0;
  for i := 0 to FStringList.Count - 1 do begin
    if Length(FStringList[i]) > FMaxLineLength then
      FMaxLineLength := Length(FStringList[i]);
  end;
  FHorzScrollBar.Max :=FMaxLineLength + 1 + FHorzScrollBar.PageSize;
end;

procedure TPHPEdit.ActionAdd(AType: TActionType; BeginPos, EndPos: TPoint; Text, ReplText: String; RBlock: Boolean; Ref: PReplaceRec);
var
  i, PtrCounter: Integer;
  NextPtr: PReplaceRec;
  PtrArray: array of Pointer;
begin
  SetLength(FUndoStack, Length(FUndoStack)+1);
  FUndoStack[Length(FUndoStack)-1].ActType := AType;
  FUndoStack[Length(FUndoStack)-1].BeginPos.X := BeginPos.X;
  FUndoStack[Length(FUndoStack)-1].BeginPos.Y := BeginPos.Y;
  FUndoStack[Length(FUndoStack)-1].EndPos.X := EndPos.X;
  FUndoStack[Length(FUndoStack)-1].EndPos.Y := EndPos.Y;
  FUndoStack[Length(FUndoStack)-1].RpBlock := RBlock;
  FUndoStack[Length(FUndoStack)-1].Ref := Ref;

  FUndoStack[Length(FUndoStack)-1].Text := Text;
  FUndoStack[Length(FUndoStack)-1].ReplText := ReplText;

  {----------------------------------------------------------------------------}
  PtrCounter := 0;
  for i := 0 to Length(FRedoStack) - 1 do begin
    NextPtr := FRedoStack[i].Ref;
    while NextPtr <> nil do begin
      NextPtr := NextPtr^.Next;
      Inc(PtrCounter);
    end;
  end;

  SetLength(PtrArray, PtrCounter);
  PtrCounter := 0;
  for i := 0 to Length(FRedoStack) - 1 do begin
    NextPtr := FRedoStack[i].Ref;
    while NextPtr <> nil do begin
      PtrArray[PtrCounter] := NextPtr;
      NextPtr := NextPtr^.Next;
      Inc(PtrCounter);
    end;
  end;

  for i := 0 to Length(PtrArray) - 1 do begin
    SetLength(PReplaceRec(PtrArray[i])^.Mask, 0);
    Dispose(PtrArray[i]);
  end;

  SetLength(PtrArray, 0);
  SetLength(FRedoStack, 0);
  {----------------------------------------------------------------------------}
end;

procedure TPHPEdit.SwapUR(URType: TURType);
begin
  if URType = urUndo then begin
    SetLength(FRedoStack, Length(FRedoStack) + 1);

    FRedoStack[Length(FRedoStack) - 1].ActType := FUndoStack[Length(FUndoStack) - 1].ActType;
    FRedoStack[Length(FRedoStack) - 1].Text := FUndoStack[Length(FUndoStack) - 1].Text;
    FRedoStack[Length(FRedoStack) - 1].ReplText := FUndoStack[Length(FUndoStack) - 1].ReplText;
    FRedoStack[Length(FRedoStack) - 1].BeginPos.X := FUndoStack[Length(FUndoStack) - 1].BeginPos.X;
    FRedoStack[Length(FRedoStack) - 1].BeginPos.Y := FUndoStack[Length(FUndoStack) - 1].BeginPos.Y;
    FRedoStack[Length(FRedoStack) - 1].EndPos.X := FUndoStack[Length(FUndoStack) - 1].EndPos.X;
    FRedoStack[Length(FRedoStack) - 1].EndPos.Y := FUndoStack[Length(FUndoStack) - 1].EndPos.Y;
    FRedoStack[Length(FRedoStack) - 1].RpBlock := FUndoStack[Length(FUndoStack) - 1].RpBlock;
    FRedoStack[Length(FRedoStack) - 1].Ref := FUndoStack[Length(FUndoStack) - 1].Ref;
  end;

  if URType = urRedo then begin
    SetLength(FUndoStack, Length(FUndoStack) + 1);

    FUndoStack[Length(FUndoStack) - 1].ActType := FRedoStack[Length(FRedoStack) - 1].ActType;
    FUndoStack[Length(FUndoStack) - 1].Text := FRedoStack[Length(FRedoStack) - 1].Text;
    FUndoStack[Length(FUndoStack) - 1].ReplText := FRedoStack[Length(FRedoStack) - 1].ReplText;    
    FUndoStack[Length(FUndoStack) - 1].BeginPos.X := FRedoStack[Length(FRedoStack) - 1].BeginPos.X;
    FUndoStack[Length(FUndoStack) - 1].BeginPos.Y := FRedoStack[Length(FRedoStack) - 1].BeginPos.Y;
    FUndoStack[Length(FUndoStack) - 1].EndPos.X := FRedoStack[Length(FRedoStack) - 1].EndPos.X;
    FUndoStack[Length(FUndoStack) - 1].EndPos.Y := FRedoStack[Length(FRedoStack) - 1].EndPos.Y;
    FUndoStack[Length(FUndoStack) - 1].RpBlock := FRedoStack[Length(FRedoStack) - 1].RpBlock;
    FUndoStack[Length(FUndoStack) - 1].Ref := FRedoStack[Length(FRedoStack) - 1].Ref;
  end;
end;

procedure TPHPEdit.Undo;
var
  TopIndex: Integer;
  BeginPos, EndPos: TPoint;
  S, InsS: String;
  NextPtr: PReplaceRec;
  ScanFrom, CurLine, shf, replcounter: Integer;
  i, PrLen: Integer;
  ValignBlock: Boolean;
begin
  FKeyChanged := False;
  FDelChanged := False;
  FBkChanged  := False;
  ValignBlock := False;
  
  if Length(FUndoStack) = 0 then Exit;

  TopIndex := Length(FUndoStack) - 1;
  BeginPos.X := FUndoStack[TopIndex].BeginPos.X;
  BeginPos.Y := FUndoStack[TopIndex].BeginPos.Y;
  EndPos.X := FUndoStack[TopIndex].EndPos.X;
  EndPos.Y := FUndoStack[TopIndex].EndPos.Y;
  ScanFrom := BeginPos.Y;

  SwapUR(urUndo);

  if FUndoStack[TopIndex].ActType = actInsert then begin
    DeleteTextBlock(BeginPos, EndPos);
    SetLength(FUndoStack, Length(FUndoStack) - 1);
    ValignBlock := True;
  end else if FUndoStack[TopIndex].ActType = actDelete then begin
    InsertTextBlock(FUndoStack[TopIndex].Text, BeginPos.Y, BeginPos.X);
    SetLength(FUndoStack, Length(FUndoStack) - 1);
    ValignBlock := True;
  end else if FUndoStack[TopIndex].ActType = actReplace then begin
    replcounter := 0;
    CurLine := 0;
    shf := 0;

    NextPtr := FUndoStack[TopIndex].Ref;
    while NextPtr <> nil do begin
      Inc(replcounter);
      BeginPos.X := NextPtr^.X;
      BeginPos.Y := NextPtr^.Y;
      EndPos.X := NextPtr^.X + Length(FUndoStack[TopIndex].ReplText);
      EndPos.Y := NextPtr^.Y;

      if BeginPos.Y <> CurLine then begin
        CurLine := BeginPos.Y;
        shf := 0;
      end;
      
      S := FStringList[BeginPos.Y];
      PrLen := Length(S);
      Delete(S, BeginPos.X-shf, Length(FUndoStack[TopIndex].ReplText));
      InsS := FUndoStack[TopIndex].Text;
      for i := 0 to Length(NextPtr^.Mask) - 1 do begin
        if NextPtr^.Mask[i] <> #0 then InsS[i+1] := NextPtr^.Mask[i];
      end;
      Insert(InsS, S, BeginPos.X-shf);
      FStringList[BeginPos.Y] := S;
      shf := shf + (Length(FUndoStack[TopIndex].ReplText) -  Length(FUndoStack[TopIndex].Text));

      NextPtr := NextPtr^.Next;
      if ScanFrom > BeginPos.Y then ScanFrom := BeginPos.Y;
    end;

    if FUndoStack[TopIndex].RpBlock then begin
      FCaretPos.Y := BeginPos.Y;
      FCaretPos.X := 1;
      ValignBlock := True;
    end
    else if (replcounter = 1)  then begin
      FCaretPos.X := BeginPos.X + Length(FUndoStack[TopIndex].Text);
      FCaretPos.Y := BeginPos.Y;
    end;

    SetLength(FUndoStack, Length(FUndoStack) - 1);
  end;

  SetLength(FLineStateAr, FStringList.Count + 1);
  ReCalcScrollRange;
  SetScanStartLine(ScanFrom);
  ScanMaxLineLen;
  if (replcounter = 1) or ValignBlock then begin
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
  end;
  GoScan;
end;

procedure TPHPEdit.Redo;
var
  TopIndex: Integer;
  BeginPos, EndPos: TPoint;
  S: String;
  Nx: Boolean;
  NextPtr: PReplaceRec;
  ScanFrom, replcounter: Integer;
  replflag: Boolean;
  ValignBlock: Boolean;
begin
  FKeyChanged := False;
  FDelChanged := False;
  FBkChanged  := False;
  replflag := False;
  ValignBlock := False;
  
  if Length(FRedoStack) = 0 then Exit;

  TopIndex := Length(FRedoStack) - 1;
  BeginPos.X := FRedoStack[TopIndex].BeginPos.X;
  BeginPos.Y := FRedoStack[TopIndex].BeginPos.Y;
  EndPos.X := FRedoStack[TopIndex].EndPos.X;
  EndPos.Y := FRedoStack[TopIndex].EndPos.Y;
  ScanFrom := BeginPos.Y;

  SwapUR(urRedo);

  if FRedoStack[TopIndex].ActType = actInsert then begin
    InsertTextBlock(FRedoStack[TopIndex].Text, BeginPos.Y, BeginPos.X);
    SetLength(FRedoStack, Length(FRedoStack) - 1);
    ValignBlock := True;
  end else if FRedoStack[TopIndex].ActType = actDelete then begin
    DeleteTextBlock(BeginPos, EndPos);
    SetLength(FRedoStack, Length(FRedoStack) - 1);
    ValignBlock := True;
  end else if FRedoStack[TopIndex].ActType = actReplace then begin
    NextPtr := FRedoStack[TopIndex].Ref;
    replcounter := 0;

    while NextPtr <> nil do begin
      Inc(replcounter);
      BeginPos.X := NextPtr^.X;
      BeginPos.Y := NextPtr^.Y;
      EndPos.X := NextPtr^.X + Length(FRedoStack[TopIndex].Text);
      EndPos.Y := NextPtr^.Y;

      S := FStringList[BeginPos.Y];
      Delete(S, BeginPos.X, Length(FRedoStack[TopIndex].Text));
      Insert(FRedoStack[TopIndex].ReplText, S, BeginPos.X);
      FStringList[BeginPos.Y] := S;

      NextPtr := NextPtr^.Next;
      if ScanFrom > BeginPos.Y then ScanFrom := BeginPos.Y;  
    end;

    if FRedoStack[TopIndex].RpBlock then begin
      FCaretPos.Y := BeginPos.Y;
      FCaretPos.X := 1;
      ValignBlock := True;
    end
    else if replcounter = 1 then begin
      FCaretPos.X := BeginPos.X + Length(FRedoStack[TopIndex].ReplText);
      FCaretPos.Y := BeginPos.Y;
    end
    else if replcounter > 1 then begin
      replflag :=  True;
    end;
    
    SetLength(FRedoStack, Length(FRedoStack) - 1);
  end;
  
  SetLength(FLineStateAr, FStringList.Count + 1);
  ReCalcScrollRange;
  SetScanStartLine(ScanFrom);
  ScanMaxLineLen;
  if not replflag or ValignBlock then begin
    ValignWindowIfCursorHide;
    AlignWindowIfCursorHide;
  end;
  GoScan;
end;

procedure TPHPEdit.AddState(var StateAr: TStateArray; LineN:Integer; State: TState; var NewPos: Integer; j: Integer);
var
  i,slen: Integer;
begin
  if (Length(StateAr[LineN].Pos) - 5) < NewPos then begin
    SetLength(StateAr[LineN].Pos, Length(StateAr[LineN].Pos) + 10);
    SetLength(StateAr[LineN].J, Length(StateAr[LineN].J) + 10);
  end;

  if NewPos > 0 then begin
    slen := j - StateAr[LineN].J[NewPos-1];

    if slen > FBigStringPartLen then begin
      for i := 0 to (slen div FBigStringPartLen) - 1 do begin
        StateAr[LineN].Pos[NewPos] := StateAr[LineN].Pos[NewPos-1];
        StateAr[LineN].J[NewPos] :=  StateAr[LineN].J[NewPos-1] + FBigStringPartLen;
        StateAr[LineN].Max := NewPos;
        Inc(NewPos);

        if (Length(StateAr[LineN].Pos) - 5) < NewPos then begin
          SetLength(StateAr[LineN].Pos, Length(StateAr[LineN].Pos) + 10);
          SetLength(StateAr[LineN].J, Length(StateAr[LineN].J) + 10);
        end;
      end;

      StateAr[LineN].Pos[NewPos] := State;
      StateAr[LineN].J[NewPos] :=  StateAr[LineN].J[NewPos-1] + slen mod FBigStringPartLen;
      StateAr[LineN].Max := NewPos;
    end else begin
      StateAr[LineN].Pos[NewPos] := State;
      StateAr[LineN].J[NewPos] := j;
      StateAr[LineN].Max := NewPos;
    end
  end else begin
    StateAr[LineN].Pos[NewPos] := State;
    StateAr[LineN].J[NewPos] := j;
    StateAr[LineN].Max := NewPos;
  end;

end;

procedure TPHPEdit.ResetScaner(StartLine: Integer);
begin
  gS := '';//FStringList[StartLine];
  CurWord := '';
  LinePos := 0;
  LineNo := StartLine;
  gi := 2;
  Next := True;

  if LineNo = 0 then begin
    case ScanMode of
      smPHP,smHTML,smXML,smTXT: State := ScanNormal;
      smJS: State := ScanJSBody;
      smCSS: State := ScanCSSBody;
    end;

  end else if FLineStateAr[LineNo-1].Max <> 0 then
    State := FLineStateAr[LineNo-1].Pos[FLineStateAr[LineNo-1].Max]
  else begin
    case ScanMode of
      smPHP,smHTML,smXML,smTXT: State := ScanNormal;
      smJS: State := ScanJSBody;
      smCSS: State := ScanCSSBody;
    end;
  end;

  if (FLineStateAr[LineNo-1].Max = 0) and (Length(FLineStateAr[LineNo-1].Pos) > 0) then begin
    State := FLineStateAr[LineNo-1].Pos[FLineStateAr[LineNo-1].Max];
  end;
  
  {мигает верхняя строчка, перенес в шапки ScanMode}
  AddState(FLineStateAr, LineNo, State, LinePos, 1);
  Inc(LinePos);
end;

procedure TPHPEdit.ScanText(var StateAr: TStateArray);
const
  Delim = [#9,#10,#13,#32,'!','<','>','[',']','{','}','(',')',',','.','/','?','"','''']+
          [';',':','-','+','=','*','&','#','`','@','$','%','^','\','|','~'];
  BiDelimList: array[0..7] of String = ('>=', '<=', '!=', '==','||','/*','*/','//');
var
  Ch, NextCh: Char;
  BiDelim: String;
  FirstVarCh: Boolean;

  i: Integer;

  function FindBiDelim(const BiDelim: String): Boolean;
  var
    i: Integer;
    Res: Boolean;
  begin
    Res := False;
    for i := 0 to Length(BiDelimList) - 1 do begin
      if BiDelim = BiDelimList[i] then begin
        Res := True;
        Break;
      end;
    end;
    Result := Res;
  end;

  function isDigit(const Digit: String): Boolean;
  var
    i: Integer;
    Res: Boolean;
  begin
    Res := True;
    {not digit}
    if not(Digit[1] in ['0'..'9']) then begin
      Result := False;
      Exit;
    end;
    {2,16}
    if (Digit[1] = '0') and (Length(Digit) > 2) then begin
      {2}
      if (Digit[2] = 'b') then begin
        for i := 3 to Length(Digit) do begin
          if not(Digit[i] in ['0','1']) then begin
            Res := False;
            Break;
          end;
        end;
      end
      {16}
      else if (Digit[2] = 'x') or (Digit[2] = 'X') then begin
        for i := 3 to Length(Digit) do begin
          if not(Digit[i] in ['0'..'9','a','b','c','d','e','f', 'A', 'B', 'C', 'D', 'E', 'F']) then begin
            Res := False;
            Break;
          end;
        end;
      end
      {8}
      else  begin
        for i := 3 to Length(Digit) do begin
          if not(Digit[i] in ['0'..'9']) then begin {or ['0'..'7']}
            Res := False;
            Break;
          end;
        end;
      end
    end
    {8,10}
    else begin
      for i := 2 to Length(Digit) do begin
        if not(Digit[i] in ['0'..'9']) then begin
          Res := False;
          Break;
        end;
      end;
    end;
    Result := Res;
  end;

begin
  InScan := True;

  while LineNo < FStringList.Count  do begin
    if FTerminate then
      Break
    else begin
      gS := FStringList[LineNo] + #13#10;
      gi := 2;

      case FScanMode of
        smPHP: begin
          //AddState(FLineStateAr, LineNo, ScanNormal, LinePos, 1);
          //Inc(LinePos);
          
          while gi <= Length(gS) + 1 do begin
            Ch := gS[gi-1];
            if gi <= Length(gS) then
              NextCh := gS[gi]
            else NextCh := #32;

            case State of
              ScanNormal: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanNormal;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanNormal;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanNormal;
                end
                else if (LowerCase(Copy(gS,gi-1,6)) = '<style')  then begin
                  if (Length(gS) >= (gi + 5)) and (gS[gi+5] in Delim) then begin
                    State := ScanCSSTag;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,5);
                    State := ScanOpenCSS;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end;
                end
                else if (LowerCase(Copy(gS,gi-1,7)) = '<script') then begin
                  if (Length(gS) >= (gi + 6)) and (gS[gi+6] in Delim) then begin
                    State := ScanJSTag;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,6);
                    State := ScanOpenJS;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end;
                end
                else if (Ch = '<') and (NextCh = '/') then begin
                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if LowerCase(CurWord) = 'style' then begin
                          AddState(StateAr, LineNo, ScanCSSTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseCSS;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end
                        else if FHtmlTagList.Find(CurWord, FIndex) then begin
                          AddState(StateAr, LineNo, ScanHTMLTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseHTML;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end;
                      end;
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '<' then begin

                  for i := gi to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if FHtmlTagList.Find(CurWord, FIndex) then begin
                          AddState(StateAr, LineNo, ScanHTMLTag, LinePos, i-Length(CurWord)-1);
                          Inc(LinePos);
                          State := ScanOpenHTML;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end;
                      end;
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;

                end;
              end;

              {HTMLSCAN HTMLSCAN HTMLSCAN HTMLSCAN HTMLSCAN HTMLSCAN HTMLSCAN}
              ScanOpenHTML: begin
                if Copy(gS,gi-1,5) = '<?php' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanOpenHTML;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanOpenHTML;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanOpenHTML;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1); {or Inc(gi,1)}
                  end;
                end
                else if (Ch in Delim) and (Ch <> '-')  then begin
                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQHTML;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQHTML;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQHTML: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanDblQHTML;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanDblQHTML;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanDblQHTML;
                end
                else if Ch = '"' then begin
                  State := ScanOpenHTML;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQHTML: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanSingQHTML;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanSingQHTML;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanSingQHTML;
                end
                else if Ch = '''' then begin
                  State := ScanOpenHTML;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCloseHTML: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanCloseHTML;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanCloseHTML;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanCloseHTML;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanHTMLComment: begin
               if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanHTMLComment;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanHTMLComment;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanHTMLComment;
                end
                else if Copy(gS,gi-1,3) = '-->' then begin
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                end
              end;

              ScanHTMLHeader: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanHTMLHeader;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanHTMLHeader;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanHTMLHeader;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanHTMLHeader, LinePos, gi);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end
              end; 
              {END SCANHTML END SCANHTML END SCANHTML END SCANHTML END SCANHTML}
              {----------------------------------------------------------------}
              {SCANCSS SCANCSS SCANCSS SCANCSS SCANCSS SCANCSS SCANCSS SCANCSS }
              ScanOpenCSS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanOpenCSS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanOpenCSS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanOpenCSS;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex))then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanCSSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanCSSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanCSSBody;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQCSS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQCSS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQCSS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanDblQCSS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanDblQCSS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanDblQCSS;
                end
                else if Ch = '"' then begin
                  State := ScanOpenCSS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQCSS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanSingQCSS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanSingQCSS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanSingQCSS;
                end
                else if Ch = '''' then begin
                  State := ScanOpenCSS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;
          
              ScanCloseCSS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanCloseCSS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanCloseCSS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanCloseCSS;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1); {or Inc(gi,1)}
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanCSSTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCSSBody: begin
                if Copy(gS,gi-1,5) = '<?php' then begin

                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanCSSBody;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin

                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanCSSBody;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin

                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanCSSBody;
                end
                else if (Ch = '<') and (NextCh = '/') then begin

                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if LowerCase(CurWord) = 'style' then begin
                          AddState(StateAr, LineNo, ScanCSSTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseCSS;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end
                      end;
                      CurWord := '';
                      Break;
                    end else
                      CurWord := CurWord + gS[i];
                  end;
                end;

                if (Ch in Delim) and (Ch <> '-')  then begin
                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;
                end;

                if (Ch = '/') and (NextCh = '*') then begin
                  state := ScanCSSComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi);
                end;

                if not(Ch in Delim) then CurWord := CurWord + Ch;
                if (Ch = '-') then CurWord := CurWord + Ch;
              end;

              ScanCSSComment: begin
              if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanCSSComment;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanCSSComment;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanCSSComment;
                end
                else if (Ch = '*') and (NextCh = '/') then begin
                  State := ScanCSSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                end;
              end;
              {END SCANCSS END SCANCSS END SCANCSS END SCANCSS END SCANCSS}
              {-----------------------------------------------------------}
              {SCANJS SCANJS SCANJS SCANJS SCANJS SCANJS SCANJS SCANJS SCANJS}
              ScanOpenJS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanOpenJS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenJS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanOpenJS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin

                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenJS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanOpenJS;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanOpenJS, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenJS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanJSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanJSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanJSBody;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQJS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanDblQJS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanDblQJS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanDblQJS;
                end
                else if Ch = '"' then begin
                  State := ScanOpenJS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQJS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanSingQJS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanSingQJS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanSingQJS;
                end
                else if Ch = '''' then begin
                  State := ScanOpenJS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCloseJS: begin
                if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanCloseJS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanCloseJS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanCloseJS;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanJSTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanJSBody: begin
                Next := True;

                if Copy(gS,gi-1,5) = '<?php' then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanJSBody;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanJSBody;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanJSBody;
                end
                else if (Ch = '<') and (NextCh = '/') then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if LowerCase(CurWord) = 'script' then begin
                          AddState(StateAr, LineNo, ScanJSTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseJS;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end
                      end;
                      CurWord := '';
                      Break;
                    end else
                      CurWord := CurWord + gS[i];
                  end;
                end;

                if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '/')  then begin
                    State := ScanLineJSComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if (Ch = '/') and (NextCh = '*') then begin
                    state := ScanJSComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingStringJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblStringJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;

                end else 
                  CurWord := CurWord + Ch;
              end;

              ScanSingStringJS: begin {
                if (Ch = '\') and (NextCh = '''') then begin
                  Inc(gi);
                end; }
                if Ch = '''' then begin
                  CurWord := '';
                  State := ScanJSBody;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end else if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanSingStringJS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanSingStringJS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanSingStringJS;
                end
              end;
              ScanDblStringJS: begin {
                if (Ch = '\') and (NextCh = '"') then begin
                  Inc(gi);
                end; }
                if Ch = '"' then begin
                  CurWord := '';
                  State := ScanJSBody;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end
                else if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanDblStringJS;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanDblStringJS;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanDblStringJS;
                end
              end;

              ScanJSComment: begin
              if Copy(gS,gi-1,5) = '<?php' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+4);
                  Inc(LinePos);
                  Inc(gi,4);
                  ReturnState := ScanJSComment;
                end
                else if Copy(gS,gi-1,3) = '<?=' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                  ReturnState := ScanJSComment;
                end
                else if Copy(gS,gi-1,2) = '<?' then begin
                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  state := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                  ReturnState := ScanJSComment;
                end
                else if (Ch = '*') and (NextCh = '/') then begin
                  State := ScanJSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                end;
              end;

              ScanLineJSComment: begin
                if Ch = #10 then begin
                  CurWord := '';
                  State := ScanJSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                end;
              end;
              {END SCANJS END SCANJS END SCANJS END SCANJS END SCANJS END SCANJS}

              ScanPHP: begin
                Next := True;

                if Ch = '''' then begin         
                  if CurWord <> '' then begin
                    //<-CurWord
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FPHPReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FPHPFuncList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanFunc, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;
                  //<-Ch
                  State := ScanSingleQuoted;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                end
                else if Ch = '"' then begin
                  if CurWord <> '' then begin
                    //<-CurWord
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FPHPReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FPHPFuncList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanFunc, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;  ;
                    CurWord := '';
                  end;
                  //<-Ch
                  State := ScanDoubleQuoted;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                end
                else if (Ch in Delim) and (Ch <> ':') and (Ch <> '\') then begin
                  if CurWord <> '' then begin

                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FPHPReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FPHPFuncList.Find(CurWord,FIndex) then begin

                      AddState(StateAr, LineNo, ScanFunc, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';

                    AddState(StateAr, LineNo, ScanPHP, LinePos, gi-1);
                    Inc(LinePos);
                  end;
                  if Ch = '#' then begin
                    State := ScanLineComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '$' then begin
                    State := ScanVar;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    FirstVarCh := True;
                  end;
                  if (NextCh in Delim) then begin
                    BiDelim := Ch + NextCh;
                    if FindBiDelim(BiDelim) then begin
                      if BiDelim = '/*' then begin
                        State := ScanComment;
                        AddState(StateAr, LineNo, State, LinePos, gi-1);
                        Inc(LinePos);
                        Inc(gi,1);
                      end else if BiDelim = '//' then begin
                        State := ScanLineComment;
                        AddState(StateAr, LineNo, State, LinePos, gi-1);
                        Inc(LinePos);
                        Inc(gi);
                      end else begin
                        //<-BiDelim
                      end;
                      Ch := #32;
                    end;
                  end;
                  if not(Ch in [#9,#10,#13,#32]) then
                    //<-Ch
                end else
                  CurWord := CurWord + Ch;

                if Copy(gS,gi-1,2) = '?>' then begin
                  if ReturnState = ScanNull then ReturnState := ScanNormal;

                  AddState(StateAr, LineNo, ScanPHPTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ReturnState;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi,1);

                  ReturnState := ScanNull;
                end;
              end;

              ScanSingleQuoted: begin
                if (Ch = '\') and (NextCh = '''') then begin
                  Inc(gi);
                end;
                if Ch = '''' then begin
                  CurWord := '';
                  State := ScanPHP;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end
              end;
              ScanDoubleQuoted: begin
                if (Ch = '\') and (NextCh = '"') then begin
                  Inc(gi);
                end;
                if Ch = '"' then begin
                  CurWord := '';
                  State := ScanPHP;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end
              end;
              ScanComment: begin
                if (Ch = '*') and (NextCh = '/') then begin
                  CurWord := '';
                  Inc(gi,2);
                  State := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end;
              end;
              ScanLineComment: begin
                if Ch = #10 then begin
                  CurWord := '';
                  State := ScanPHP;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                end;
              end;
              ScanVar: begin
                if FirstVarCh then begin
                  if not (Ch in ['_','a'..'z','A'..'Z','$']) then begin
                    CurWord := '';
                    State := ScanPHP;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Next := False;
                  end;
                  FirstVarCh := False;
                end else begin
                  if not (Ch in ['_','a'..'z','A'..'Z','0'..'9','$']) then begin
                    CurWord := '';
                    State := ScanPHP;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Next := False;
                  end;
                end;
              end;
            end;

            if Next then begin
              Inc(gi);
            end;

            if (Ch = #10) and (LineNo < Length(StateAr)-1) then begin
              AddState(StateAr, LineNo, State, LinePos, gi-1);
              Inc(LineNo);
              LinePos := 0;

              AddState(StateAr, LineNo, State, LinePos, 1);
              Inc(LinePos);

              if LineNo mod FPerProcessMessages = 0 then
                Application.ProcessMessages;

            end;
          end;
        end;

        smHTML: begin
          //AddState(FLineStateAr, LineNo, ScanNormal, LinePos, 1);
          //Inc(LinePos);
          
          while gi <= Length(gS) + 1 do begin
            Ch := gS[gi-1];
            if gi <= Length(gS) then
              NextCh := gS[gi]
            else NextCh := #32;

            case State of
              ScanNormal: begin
                if (LowerCase(Copy(gS,gi-1,6)) = '<style')  then begin
                  if (Length(gS) >= (gi + 5)) and (gS[gi+5] in Delim) then begin
                    State := ScanCSSTag;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,5);
                    State := ScanOpenCSS;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end;
                end
                else if (LowerCase(Copy(gS,gi-1,7)) = '<script') then begin
                  if (Length(gS) >= (gi + 6)) and (gS[gi+6] in Delim) then begin
                    State := ScanJSTag;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,6);
                    State := ScanOpenJS;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end;
                end
                else if (Ch = '<') and (NextCh = '/') then begin
                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if LowerCase(CurWord) = 'style' then begin
                          AddState(StateAr, LineNo, ScanCSSTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseCSS;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end
                        else if FHtmlTagList.Find(CurWord, FIndex) then begin
                          AddState(StateAr, LineNo, ScanHTMLTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseHTML;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end;
                      end;
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '<' then begin

                  for i := gi to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if FHtmlTagList.Find(CurWord, FIndex) then begin
                          AddState(StateAr, LineNo, ScanHTMLTag, LinePos, i-Length(CurWord)-1);
                          Inc(LinePos);
                          State := ScanOpenHTML;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end;
                      end;
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;

                end;
              end;

              ScanOpenHTML: begin
               if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1); {or Inc(gi,1)}
                  end;
                end
                else if (Ch in Delim) and (Ch <> '-')  then begin
                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQHTML;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQHTML;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQHTML: begin
                if Ch = '"' then begin
                  State := ScanOpenHTML;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQHTML: begin
                if Ch = '''' then begin
                  State := ScanOpenHTML;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCloseHTML: begin
                if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanHTMLComment: begin
               if Copy(gS,gi-1,3) = '-->' then begin
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                end
              end;

              ScanHTMLHeader: begin
                if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanHTMLHeader, LinePos, gi);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end
              end;

              ScanOpenCSS: begin
                if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenCSS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanCSSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanCSSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanCSSBody;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQCSS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQCSS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQCSS: begin
                if Ch = '"' then begin
                  State := ScanOpenCSS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQCSS: begin
                if Ch = '''' then begin
                  State := ScanOpenCSS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCloseCSS: begin
                if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1); {or Inc(gi,1)}
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanCSSTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCSSBody: begin
                if (Ch = '<') and (NextCh = '/') then begin

                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if LowerCase(CurWord) = 'style' then begin
                          AddState(StateAr, LineNo, ScanCSSTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseCSS;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end
                      end;
                      CurWord := '';
                      Break;
                    end else
                      CurWord := CurWord + gS[i];
                  end;
                end;
                
                if (Ch in Delim) and (Ch <> '-')  then begin
                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;
                end;

                if (Ch = '/') and (NextCh = '*') then begin
                  state := ScanCSSComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi);
                end;

                if not(Ch in Delim) then CurWord := CurWord + Ch;
              end;

              ScanCSSComment: begin
                if (Ch = '*') and (NextCh = '/') then begin
                  State := ScanCSSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                end;
              end;

              ScanOpenJS: begin
                if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if (FHtmlAttrList.Find(CurWord, FIndex)) or (FHtmlMethodsList.Find(CurWord, FIndex)) then begin
                      AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanOpenJS, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanOpenJS, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanJSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanJSTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanJSBody;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQJS: begin
                if Ch = '"' then begin
                  State := ScanOpenJS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQJS: begin
                if Ch = '''' then begin
                  State := ScanOpenJS;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCloseJS: begin
                if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanJSTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanJSBody: begin
                Next := True;

                if (Ch = '<') and (NextCh = '/') then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        if LowerCase(CurWord) = 'script' then begin
                          AddState(StateAr, LineNo, ScanJSTag, LinePos, i-Length(CurWord)-2);
                          Inc(LinePos);
                          State := ScanCloseJS;
                          AddState(StateAr, LineNo, State, LinePos, i);
                          Inc(LinePos);
                          gi := i;
                        end
                      end;
                      CurWord := '';
                      Break;
                    end else
                      CurWord := CurWord + gS[i];
                  end;
                end;
                if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '/')  then begin
                    State := ScanLineJSComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if (Ch = '/') and (NextCh = '*') then begin
                    state := ScanJSComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingStringJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblStringJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;

                end else 
                  CurWord := CurWord + Ch;
              end;

              ScanSingStringJS: begin {
                if (Ch = '\') and (NextCh = '''') then begin
                  Inc(gi);
                end; }
                if Ch = '''' then begin
                  CurWord := '';
                  State := ScanJSBody;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end;
              end;
              ScanDblStringJS: begin {
                if (Ch = '\') and (NextCh = '"') then begin
                  Inc(gi);
                end; }
                if Ch = '"' then begin
                  CurWord := '';
                  State := ScanJSBody;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end;
              end;

              ScanJSComment: begin
                if (Ch = '*') and (NextCh = '/') then begin
                  State := ScanJSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                end;
              end;

              ScanLineJSComment: begin
                if Ch = #10 then begin
                  CurWord := '';
                  State := ScanJSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                end;
              end;
            end;

            if Next then begin
              Inc(gi);
            end;

            if (Ch = #10) and (LineNo < Length(StateAr)-1) then begin
              AddState(StateAr, LineNo, State, LinePos, gi-1);
              Inc(LineNo);
              LinePos := 0;

              AddState(StateAr, LineNo, State, LinePos, 1);
              Inc(LinePos);

              if LineNo mod FPerProcessMessages = 0 then
                Application.ProcessMessages;
            end;
          end;
        end;// End smHTML

        smJS: begin
          //AddState(FLineStateAr, LineNo, ScanJSBody, LinePos, 1);
          //Inc(LinePos);

          while gi <= Length(gS) + 1 do begin
            Ch := gS[gi-1];
            if gi <= Length(gS) then
              NextCh := gS[gi]
            else NextCh := #32;

            case State of
              ScanJSBody: begin
                Next := True;

                if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    if isDigit(CurWord) then begin
                      AddState(StateAr, LineNo, ScanDigit, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos)
                    end
                    else if FJSReservList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSReserv, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSObjectList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSObj, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSMethodsList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSMetods, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end
                    else if FJSPropList.Find(CurWord,FIndex) then begin
                      AddState(StateAr, LineNo, ScanJSProp, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                    end;

                    AddState(StateAr, LineNo, ScanJSBody, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '/')  then begin
                    State := ScanLineJSComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if (Ch = '/') and (NextCh = '*') then begin
                    state := ScanJSComment;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingStringJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblStringJS;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;

                end else
                  CurWord := CurWord + Ch;
              end;

              ScanSingStringJS: begin {
                if (Ch = '\') and (NextCh = '''') then begin
                  Inc(gi);
                end; }
                if Ch = '''' then begin
                  CurWord := '';
                  State := ScanJSBody;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end;
              end;
              ScanDblStringJS: begin {
                if (Ch = '\') and (NextCh = '"') then begin
                  Inc(gi);
                end; }
                if Ch = '"' then begin
                  CurWord := '';
                  State := ScanJSBody;
                  Inc(gi);
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Next := False;
                end;
              end;

              ScanJSComment: begin
                if (Ch = '*') and (NextCh = '/') then begin
                  State := ScanJSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                  Inc(gi);
                end;
              end;

              ScanLineJSComment: begin
                if Ch = #10 then begin
                  CurWord := '';
                  State := ScanJSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                end;
              end;
            end;
            {END SCANJS END SCANJS END SCANJS END SCANJS END SCANJS END SCANJS}

            if Next then begin
              Inc(gi);
            end;

            if (Ch = #10) and (LineNo < Length(StateAr)-1) then begin
              AddState(StateAr, LineNo, State, LinePos, gi-1);
              Inc(LineNo);
              LinePos := 0;

              AddState(StateAr, LineNo, State, LinePos, 1);
              Inc(LinePos);

              if LineNo mod FPerProcessMessages = 0 then
                Application.ProcessMessages;
            end;
          end;
        end;// End smJS

        smCSS: begin
          //AddState(FLineStateAr, LineNo, ScanCSSBody, LinePos, 1);
          //Inc(LinePos);
          
          while gi <= Length(gS) + 1 do begin
            Ch := gS[gi-1];
            if gi <= Length(gS) then
              NextCh := gS[gi]
            else NextCh := #32;

            case State of

              ScanCSSBody: begin
                if (Ch in Delim) and (Ch <> '-')  then begin
                  if (CurWord <> '')  then begin
                    if FCSSAttrList.Find(CurWord, FIndex) then begin
                      AddState(StateAr, LineNo, ScanCSSAttr, LinePos, gi-Length(CurWord)-1);
                      Inc(LinePos);
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end else begin
                      AddState(StateAr, LineNo, ScanCSSBody, LinePos, gi-1);
                      Inc(LinePos);
                    end;
                    CurWord := '';
                  end;
                end;

                if (Ch = '/') and (NextCh = '*') then begin
                  state := ScanCSSComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi);
                end;

                if not(Ch in Delim) then CurWord := CurWord + Ch;
                if (Ch = '-') then CurWord := CurWord + Ch;
              end;

              ScanCSSComment: begin
                if (Ch = '*') and (NextCh = '/') then begin
                  State := ScanCSSBody;
                  AddState(StateAr, LineNo, State, LinePos, gi+1);
                  Inc(LinePos);
                end;
              end;
            end;

            if Next then begin
              Inc(gi);
            end;

            if (Ch = #10) and (LineNo < Length(StateAr)-1) then begin
              AddState(StateAr, LineNo, State, LinePos, gi-1);
              Inc(LineNo);
              LinePos := 0;

              AddState(StateAr, LineNo, State, LinePos, 1);
              Inc(LinePos);

              if LineNo mod FPerProcessMessages = 0 then
                Application.ProcessMessages;
            end;
          end;
        end;// End smCSS


        smXML: begin
          //AddState(FLineStateAr, LineNo, ScanNormal, LinePos, 1);
          //Inc(LinePos);

          while gi <= Length(gS) + 1 do begin
            Ch := gS[gi-1];
            if gi <= Length(gS) then
              NextCh := gS[gi]
            else NextCh := #32;

            case State of
              ScanNormal: begin
                if (Ch = '<') and (NextCh = '/') then begin
                  for i := gi+1 to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        AddState(StateAr, LineNo, ScanHTMLTag, LinePos, i-Length(CurWord)-2);
                        Inc(LinePos);
                        State := ScanCloseHTML;
                        AddState(StateAr, LineNo, State, LinePos, i);
                        Inc(LinePos);
                        gi := i;
                      end;
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;
                end
                else if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                {else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end }
                else if (Ch = '<') and (NextCh = '?') then begin

                  for i := gi+1 to Length(gS) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                        Inc(LinePos);
                        State := ScanOpenHTML;
                        AddState(StateAr, LineNo, State, LinePos, i-1+Length(CurWord));
                        Inc(LinePos);
                        gi := i;
                      end;
                      
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;

                end
                else if Ch = '<' then begin

                  for i := gi to Length(gs) do begin
                    if (gS[i] in Delim) then begin
                      if CurWord <> '' then begin
                        AddState(StateAr, LineNo, ScanHTMLTag, LinePos, i-Length(CurWord)-1);
                        Inc(LinePos);
                        State := ScanOpenHTML;
                        AddState(StateAr, LineNo, State, LinePos, i);
                        Inc(LinePos);
                        gi := i;
                      end;
                      CurWord := '';
                      Break;
                    end else
                     CurWord := CurWord + gS[i];
                  end;

                end;
              end;

              ScanOpenHTML: begin
               if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if (Ch in Delim)  then begin
                  if (CurWord <> '')  then begin
                    AddState(StateAr, LineNo, ScanHTMLAttr, LinePos, gi-Length(CurWord)-1);
                    Inc(LinePos);
                    AddState(StateAr, LineNo, ScanOpenHTML, LinePos, gi-1);
                    Inc(LinePos);
                    CurWord := '';
                  end;

                  if (Ch = '/') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                  end
                  else if (Ch = '?') and (NextCh = '>') then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi+1);
                    Inc(LinePos);
                    Inc(gi);
                  end
                  else if Ch = '>' then begin
                    AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                    Inc(LinePos);
                    State := ScanNormal;
                    AddState(StateAr, LineNo, State, LinePos, gi);
                    Inc(LinePos);
                  end
                  else if Ch = '"' then begin
                    State := ScanDblQHTML;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end
                  else if Ch = '''' then begin
                    State := ScanSingQHTML;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                  end;
                end
                else
                  CurWord := CurWord + Ch;
              end;

              ScanDblQHTML: begin
                if Ch = '"' then begin
                  State := ScanOpenHTML;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanSingQHTML: begin
                if Ch = '''' then begin
                  State := ScanOpenHTML;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanCloseHTML: begin
                if Copy(gS,gi-1,4) = '<!--' then begin
                  State := ScanHTMLComment;
                  AddState(StateAr, LineNo, State, LinePos, gi-1);
                  Inc(LinePos);
                  Inc(gi,3);
                end
                else if (Copy(gS,gi-1,2) = '<!') then begin
                  if (Length(gS) >= gi+1) and (gS[gi+1] in ['a'..'z','A'..'Z']) then begin
                    State := ScanHTMLHeader;
                    AddState(StateAr, LineNo, State, LinePos, gi-1);
                    Inc(LinePos);
                    Inc(gi,1);
                  end;
                end
                else if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanHTMLTag, LinePos, gi-1);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end;
              end;

              ScanHTMLComment: begin
               if Copy(gS,gi-1,3) = '-->' then begin
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi+2);
                  Inc(LinePos);
                  Inc(gi,2);
                end
              end;

              ScanHTMLHeader: begin
                if Ch = '>' then begin
                  AddState(StateAr, LineNo, ScanHTMLHeader, LinePos, gi);
                  Inc(LinePos);
                  State := ScanNormal;
                  AddState(StateAr, LineNo, State, LinePos, gi);
                  Inc(LinePos);
                end
              end;
            end;

            if Next then begin
              Inc(gi);
            end;

            if (Ch = #10) and (LineNo < Length(StateAr)-1) then begin
              AddState(StateAr, LineNo, State, LinePos, gi-1);
              Inc(LineNo);
              LinePos := 0;

              AddState(StateAr, LineNo, State, LinePos, 1);
              Inc(LinePos);

              if LineNo mod FPerProcessMessages = 0 then
                Application.ProcessMessages;
            end;
          end;
        end;// End smXML

        smTXT: begin

          while gi <= Length(gS) + 1 do begin
            Ch := gS[gi-1];
            if gi <= Length(gS) then
              NextCh := gS[gi]
            else NextCh := #32;

            Inc(gi);

            if (Ch = #10) and (LineNo < Length(StateAr)-1) then begin
              AddState(StateAr, LineNo, State, LinePos, gi-1);
              Inc(LineNo);
              LinePos := 0;

              AddState(StateAr, LineNo, State, LinePos, 1);
              Inc(LinePos);

              if LineNo mod FPerProcessMessages = 0 then
                Application.ProcessMessages;
            end;
          end;
        end;
      end;
    end;
  end;

  FPaintBox.Repaint;
  InScan := False;
end;

procedure TPHPEdit.Terminate;
begin
  FTerminate := True;
end;

end.

